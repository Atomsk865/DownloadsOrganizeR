<!-- Bootstrap JS -->
<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js"></script>
<!-- htmx - AJAX requests via HTML attributes -->
<script src="https://unpkg.com/htmx.org@1.9.10"></script>
<script>
    // htmx configuration
    document.body.addEventListener('htmx:configRequest', (event) => {
        // Add auth headers to all htmx requests
        if (typeof getAuthHeaders === 'function') {
            const headers = getAuthHeaders();
            Object.keys(headers).forEach(key => {
                event.detail.headers[key] = headers[key];
            });
        }
    });
    
    // Handle htmx errors
    document.body.addEventListener('htmx:responseError', (event) => {
        console.error('htmx request failed:', event.detail);
        if (typeof showNotification === 'function') {
            showNotification('Request failed: ' + (event.detail.xhr.statusText || 'Unknown error'), 'danger');
        }
    });
    
    // Handle successful htmx responses
    document.body.addEventListener('htmx:afterRequest', (event) => {
        if (event.detail.successful && event.detail.xhr.response) {
            try {
                const data = JSON.parse(event.detail.xhr.response);
                // Show notification for service control actions
                if (data.status === 'success' && data.message) {
                    if (typeof showNotification === 'function') {
                        showNotification(data.message, 'success');
                    }
                } else if (data.status === 'error' && data.message) {
                    if (typeof showNotification === 'function') {
                        showNotification(data.message, 'danger');
                    }
                }
            } catch (e) {
                // Not JSON or no message - silent success
            }
        }
    });
    
    // Auto-initialize components after htmx swaps content
    document.body.addEventListener('htmx:afterSwap', (event) => {
        if (typeof initDragAndDrop === 'function') initDragAndDrop();
        if (typeof initResizableTables === 'function') initResizableTables();
    });
</script>
<!-- Alpine.js - Lightweight reactive framework -->
<script defer src="https://cdn.jsdelivr.net/npm/alpinejs@3.13.3/dist/cdn.min.js"></script>
<!-- ApexCharts - Modern charting library (replaced Chart.js) -->
<script src="https://cdn.jsdelivr.net/npm/apexcharts@3.45.1/dist/apexcharts.min.js"></script>
<!-- GridStack.js for drag-drop grid layouts -->
<script src="https://cdn.jsdelivr.net/npm/gridstack@10.1.2/dist/gridstack-all.js"></script>

<!-- MODERN UI UTILITIES - Alpine.js Helpers for Enhanced Interactivity -->
<script>
// Initialize after Alpine loads
document.addEventListener('alpine:init', () => {
    // ========== FORM VALIDATION UTILITIES ==========
    window.uiComponents = {
        // Form field validation with visual feedback
        createFormValidator: (fieldName, maxLength = null, pattern = null) => ({
            value: '',
            error: '',
            isValid: false,
            charCount: 0,
            
            validate() {
                this.charCount = this.value.length;
                
                // Check if empty
                if (!this.value.trim()) {
                    this.error = 'This field is required';
                    this.isValid = false;
                    return;
                }
                
                // Check max length
                if (maxLength && this.charCount > maxLength) {
                    this.error = `Maximum ${maxLength} characters allowed`;
                    this.isValid = false;
                    return;
                }
                
                // Check pattern (regex)
                if (pattern && !pattern.test(this.value)) {
                    this.error = 'Invalid format';
                    this.isValid = false;
                    return;
                }
                
                this.error = '';
                this.isValid = true;
            },
            
            reset() {
                this.value = '';
                this.error = '';
                this.isValid = false;
                this.charCount = 0;
            }
        }),
        
        // ========== TABLE UTILITIES ==========
        // Sortable table support
        createTableManager: (data = []) => ({
            data: data,
            sortKey: null,
            sortDirection: 'asc',
            selectedRows: [],
            
            sort(key) {
                if (this.sortKey === key) {
                    this.sortDirection = this.sortDirection === 'asc' ? 'desc' : 'asc';
                } else {
                    this.sortKey = key;
                    this.sortDirection = 'asc';
                }
                
                this.data.sort((a, b) => {
                    const aVal = a[key];
                    const bVal = b[key];
                    
                    if (typeof aVal === 'string') {
                        return this.sortDirection === 'asc' 
                            ? aVal.localeCompare(bVal)
                            : bVal.localeCompare(aVal);
                    }
                    
                    return this.sortDirection === 'asc'
                        ? aVal - bVal
                        : bVal - aVal;
                });
            },
            
            toggleRow(rowId) {
                const idx = this.selectedRows.indexOf(rowId);
                if (idx >= 0) {
                    this.selectedRows.splice(idx, 1);
                } else {
                    this.selectedRows.push(rowId);
                }
            },
            
            selectAll() {
                this.selectedRows = this.data.map((_, i) => i);
            },
            
            deselectAll() {
                this.selectedRows = [];
            },
            
            getSelectedCount() {
                return this.selectedRows.length;
            }
        }),
        
        // ========== GAUGE/METER UTILITIES ==========
        // Real-time resource gauge
        createGauge: (maxValue = 100, threshold = 80) => ({
            value: 0,
            maxValue: maxValue,
            threshold: threshold,
            isAlert: false,
            
            update(newValue) {
                this.value = Math.min(newValue, this.maxValue);
                this.isAlert = this.value >= this.threshold;
            },
            
            getPercentage() {
                return Math.round((this.value / this.maxValue) * 100);
            },
            
            getColor() {
                const pct = this.getPercentage();
                if (pct >= 80) return '#dc3545';  // Red
                if (pct >= 60) return '#ffc107';  // Yellow
                if (pct >= 40) return '#17a2b8';  // Cyan
                return '#198754';  // Green
            }
        }),
        
        // ========== NOTIFICATION UTILITIES ==========
        // Smart notification grouping
        createNotificationManager: () => ({
            notifications: [],
            autoHideDelay: 5000,
            
            add(message, type = 'info', action = null) {
                const notification = {
                    id: Date.now(),
                    message: message,
                    type: type,
                    action: action,
                    show: true
                };
                
                this.notifications.unshift(notification);
                
                // Auto-hide based on type
                if (['success', 'info'].includes(type)) {
                    setTimeout(() => this.remove(notification.id), this.autoHideDelay);
                }
            },
            
            remove(id) {
                this.notifications = this.notifications.filter(n => n.id !== id);
            },
            
            clear() {
                this.notifications = [];
            },
            
            group() {
                const grouped = {};
                this.notifications.forEach(notif => {
                    if (!grouped[notif.type]) grouped[notif.type] = [];
                    grouped[notif.type].push(notif);
                });
                return grouped;
            }
        }),
        
        // ========== UI STATE UTILITIES ==========
        // Floating action menu
        createFABMenu: () => ({
            open: false,
            items: [],
            
            toggle() {
                this.open = !this.open;
            },
            
            close() {
                this.open = false;
            },
            
            addItem(icon, label, action) {
                this.items.push({ icon, label, action });
            }
        }),
        
        // Smart form hints
        createSmartHints: () => ({
            hints: {},
            activeField: null,
            
            getHint(fieldName) {
                return this.hints[fieldName] || '';
            },
            
            setHint(fieldName, hint) {
                this.hints[fieldName] = hint;
            },
            
            showHint(fieldName) {
                this.activeField = fieldName;
            },
            
            hideHint() {
                this.activeField = null;
            }
        }),
        
        // ========== ACCESSIBILITY UTILITIES ==========
        // Keyboard navigation support
        createKeyboardHandler: () => ({
            shortcuts: {},
            
            register(key, handler, label = '') {
                this.shortcuts[key] = { handler, label };
            },
            
            handle(event) {
                const key = `${event.ctrlKey ? 'Ctrl+' : ''}${event.key.toUpperCase()}`;
                if (this.shortcuts[key]) {
                    event.preventDefault();
                    this.shortcuts[key].handler();
                }
            }
        })
    };
    
    // Register globally for Alpine components
    window.Alpine = Alpine;
    console.log('✅ Modern UI components initialized');
});

// Ensure utilities available before Alpine init
if (!window.uiComponents) {
    window.uiComponents = {};
}
</script>

<script>console.log('[Dashboard Scripts] Version: 2025-12-04-VT-FIX');</script>
<!-- Login / Change-password Modal -->
<div class="modal fade" id="loginModal" tabindex="-1" aria-labelledby="loginModalLabel" aria-hidden="true" role="dialog">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title" id="loginModalLabel">Dashboard Login</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <div class="mb-2">
                    <label for="login-username" class="form-label">Username</label>
                    <input id="login-username" class="form-control" type="text" value="admin">
                </div>
                <div class="mb-2">
                    <label for="login-password" class="form-label">Password</label>
                    <input id="login-password" class="form-control" type="password">
                </div>
                <div class="form-check mb-2">
                    <input class="form-check-input" type="checkbox" id="login-remember" checked>
                    <label class="form-check-label" for="login-remember">Remember me</label>
                </div>
                <div id="change-password-section" style="display:none;">
                    <hr>
                    <div class="mb-2">
                        <label class="form-label">New password</label>
                        <input id="new-password" class="form-control" type="password">
                    </div>
                    <div class="mb-2">
                        <label class="form-label">Confirm new password</label>
                        <input id="confirm-password" class="form-control" type="password">
                    </div>
                </div>
                <div id="login-error" class="text-danger" style="display:none;"></div>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                <button id="login-submit" type="button" class="btn btn-primary">Login</button>
                <button id="change-submit" type="button" class="btn btn-success" style="display:none;">Change Password</button>
            </div>
        </div>
    </div>
</div>
<script>
// Global auth header storage
let __authHeader = null;
let __rights = {};

// ==================== IMMEDIATE THEME RESTORATION ====================
// Apply theme IMMEDIATELY before anything else to prevent flicker
(function() {
    try {
        const stored = localStorage.getItem('dashboard_theme_v1');
        if (!stored) return;
        
        const data = JSON.parse(stored);
        if (!data || !data.theme || !data.theme.colors) return;
        
        const theme = data.theme;
        const colors = theme.colors;
        
        // Helper: Calculate if color is light
        function isLightColor(hex) {
            if (!hex || typeof hex !== 'string') return false;
            const cleanHex = hex.replace('#', '').trim();
            if (!/^[0-9A-Fa-f]{6}$/.test(cleanHex)) return false;
            const rgb = parseInt(cleanHex, 16);
            const r = (rgb >> 16) & 0xff;
            const g = (rgb >> 8) & 0xff;
            const b = (rgb >> 0) & 0xff;
            const luma = 0.299 * r + 0.587 * g + 0.114 * b;
            return luma > 128;
        }
        
        // Helper: Get contrasting text color
        function getContrastText(bgColor) {
            return isLightColor(bgColor) ? '#212529' : '#ffffff';
        }
        
        // Helper: Adjust color brightness
        function adjustColor(hex, percent) {
            if (!hex || typeof hex !== 'string') return hex || '#0d6efd';
            const cleanHex = hex.replace('#', '').trim();
            if (!/^[0-9A-Fa-f]{6}$/.test(cleanHex)) return hex;
            const num = parseInt(cleanHex, 16);
            const amt = Math.round(2.55 * percent);
            const R = Math.max(0, Math.min(255, (num >> 16) + amt));
            const G = Math.max(0, Math.min(255, ((num >> 8) & 0x00FF) + amt));
            const B = Math.max(0, Math.min(255, (num & 0x0000FF) + amt));
            return '#' + (0x1000000 + (R << 16) + (G << 8) + B).toString(16).slice(1);
        }
        
        // Extract colors
        const primary = colors.primary || '#0d6efd';
        const secondary = colors.secondary || '#6c757d';
        const success = colors.success || '#198754';
        const danger = colors.danger || '#dc3545';
        const warning = colors.warning || '#ffc107';
        const info = colors.info || '#0dcaf0';
        
        // Calculate derived colors
        const primaryText = getContrastText(primary);
        const bgLight = adjustColor(primary, 50);  // Lightened but with visible tint
        const borderRadius = theme.borderRadius || '8px';
        const fontSize = theme.fontSize || '100%';
        const shadow = theme.shadow || 'normal';
        
        const shadowMap = {
            none: 'none',
            light: '0 1px 3px rgba(0,0,0,0.1)',
            normal: '0 1px 3px rgba(0,0,0,0.12), 0 1px 2px rgba(0,0,0,0.24)',
            strong: '0 10px 40px rgba(0,0,0,0.3)'
        };
        
        // Inject CSS immediately
        const style = document.createElement('style');
        style.id = 'instant-theme-css';
        style.setAttribute('data-priority', 'critical');
        style.textContent = `:root {
            --bs-primary: ${primary} !important;
            --bs-secondary: ${secondary} !important;
            --bs-success: ${success} !important;
            --bs-danger: ${danger} !important;
            --bs-warning: ${warning} !important;
            --bs-info: ${info} !important;
            --bs-light: ${bgLight} !important;
            --bs-primary-text: ${primaryText} !important;
        }
        .card { border-radius: ${borderRadius} !important; box-shadow: ${shadowMap[shadow]} !important; }
        body { font-size: ${fontSize} !important; }
        .bg-light { background-color: ${bgLight} !important; color: ${adjustColor(primary, -60)} !important; }
        .bg-light .text-muted { color: ${adjustColor(primary, -40)} !important; }
        .bg-light .fw-bold { color: ${adjustColor(primary, -70)} !important; }
        #org-stats .card.bg-light { 
          background-color: ${bgLight} !important; 
          color: ${adjustColor(primary, -70)} !important;
        }
        #org-stats .card.bg-light * { color: ${adjustColor(primary, -70)} !important; }
        #org-stats .card.bg-light small { color: ${adjustColor(primary, -60)} !important; }
        #org-stats .card.bg-light .text-muted { color: ${adjustColor(primary, -60)} !important; }
        #org-stats .card.bg-light .display-6 { color: ${adjustColor(primary, -80)} !important; }
        #org-stats .card.bg-light .fw-bold { color: ${adjustColor(primary, -80)} !important; }
        .alert-info { background-color: ${adjustColor(info, 85)} !important; border-color: ${info} !important; color: ${adjustColor(info, -70)} !important; }
        .alert-info * { color: ${adjustColor(info, -70)} !important; }
        .btn-primary { background-color: ${primary} !important; border-color: ${primary} !important; color: ${primaryText} !important; }
        .btn-primary:hover { background-color: ${adjustColor(primary, -20)} !important; color: ${primaryText} !important; }
        .card-header { background-color: ${primary} !important; color: ${primaryText} !important; }
        a { color: ${primary} !important; }`;
        
        document.head.appendChild(style);
        
        console.log('[Theme] Applied immediately from localStorage');
    } catch (e) {
        console.warn('[Theme] Immediate restoration failed:', e);
    }
})();

// Apply theme to statistics cards on page load (after DOM is ready)
document.addEventListener('DOMContentLoaded', function() {
    const theme = localStorage.getItem('dashboardTheme');
    if (theme) {
        try {
            const parsedTheme = JSON.parse(theme);
            // Force inline styles on statistics cards
            if (typeof forceStatisticsCardsTheme === 'function') {
                forceStatisticsCardsTheme(parsedTheme);
            }
        } catch (e) {
            console.warn('[Theme] Failed to apply stats card theme on load:', e);
        }
    }
});
// ==================== END IMMEDIATE THEME RESTORATION ====================
let __configVersion = 0;
let __rightsPollIntervalMs = 60000; // 60s polling
let __csrfToken = null;
let __organizerFeatures = { virustotal_enabled: true, duplicates_enabled: true, reports_enabled: true };
let __vtApiKey = '';

// Fetch CSRF token on page load
async function fetchCSRFToken() {
    try {
        const resp = await fetch('/api/csrf-token', { credentials: 'include' });
        if (resp.ok) {
            const data = await resp.json();
            __csrfToken = data.csrf_token;
        }
    } catch (e) {
        console.warn('Failed to fetch CSRF token:', e);
    }
}

// Sidebar resizer logic (top-level)
function initSidebarResizer() {
    const resizer = document.getElementById('sidebar-resizer');
    const container = document.querySelector('.dashboard-container');
    if (!resizer || !container) return;

    // Restore saved width
    const saved = localStorage.getItem('sidebarWidth');
    if (saved) {
        document.documentElement.style.setProperty('--sidebar-width', saved);
    }

    let startX = 0;
    function onMouseDown(e) {
        startX = e.clientX;
        resizer.classList.add('active');
        document.body.style.cursor = 'col-resize';
        document.addEventListener('mousemove', onMouseMove);
        document.addEventListener('mouseup', onMouseUp);
    }

    function onMouseMove(e) {
        const rect = container.getBoundingClientRect();
        const diffPx = e.clientX - rect.left;
        let pct = (diffPx / rect.width) * 100;
        pct = Math.max(15, Math.min(35, pct)); // clamp between 15% and 35%
        const pctStr = pct.toFixed(1) + '%';
        document.documentElement.style.setProperty('--sidebar-width', pctStr);
    }

    function onMouseUp() {
        resizer.classList.remove('active');
        document.body.style.cursor = '';
        document.removeEventListener('mousemove', onMouseMove);
        document.removeEventListener('mouseup', onMouseUp);
        const current = getComputedStyle(document.documentElement).getPropertyValue('--sidebar-width').trim();
        try { localStorage.setItem('sidebarWidth', current); } catch(e) {}
    }

    resizer.addEventListener('mousedown', onMouseDown);

    // Double-click to cycle presets
    const presets = [15, 20, 25, 30, 35];
    resizer.addEventListener('dblclick', function() {
        const currentStr = getComputedStyle(document.documentElement).getPropertyValue('--sidebar-width').trim() || '20%';
        const current = parseFloat(currentStr);
        let idx = presets.findIndex(p => Math.abs(p - current) < 0.51);
        idx = (idx + 1) % presets.length;
        const nextPct = presets[idx];
        const pctStr = nextPct.toFixed(0) + '%';
        document.documentElement.style.setProperty('--sidebar-width', pctStr);
        try { localStorage.setItem('sidebarWidth', pctStr); } catch(e) {}
    });
}

// Login functionality
function promptLogin() {
    document.getElementById('change-password-section').style.display = 'none';
    document.getElementById('login-submit').style.display = 'inline-block';
    document.getElementById('change-submit').style.display = 'none';
    document.getElementById('login-error').style.display = 'none';
    document.getElementById('login-password').value = '';
    const modal = new bootstrap.Modal(document.getElementById('loginModal'));
    modal.show();
}

function logout() {
    __authHeader = null;
    // Clear stored credentials
    try {
        sessionStorage.removeItem('authHeader');
    } catch (e) {}
    // Remove cookie
    document.cookie = 'authHeader=; Max-Age=0; Path=/; SameSite=Lax' + (location.protocol === 'https:' ? '; Secure' : '');
    document.getElementById('login-btn').classList.remove('d-none');
    document.getElementById('logout-btn').classList.add('d-none');
    document.getElementById('config-link').classList.add('d-none');
    showNotification('Logged out successfully', 'info');
}

document.getElementById('login-submit').addEventListener('click', async function() {
    const username = document.getElementById('login-username').value;
    const password = document.getElementById('login-password').value;
    const remember = document.getElementById('login-remember').checked;
    const credentials = btoa(username + ':' + password);
    __authHeader = 'Basic ' + credentials;
    
    // Store credentials in sessionStorage and cookie for persistence
    try {
        sessionStorage.setItem('authHeader', __authHeader);
    } catch (e) {
        console.warn('sessionStorage not available:', e);
    }
    // Persist for 14 days in cookie
    document.cookie = 'authHeader=' + encodeURIComponent(__authHeader) + '; Max-Age=' + (14*24*60*60) + '; Path=/; SameSite=Lax' + (location.protocol === 'https:' ? '; Secure' : '');
    
    try {
        // Also establish server-side session with remember cookie
        try {
            await fetch('/login', {
                method: 'POST',
                credentials: 'include',
                headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
                body: new URLSearchParams({ username, password, remember: remember ? 'on' : '' })
            });
        } catch (e) {}
        const response = await fetch('/auth_check', {
            credentials: 'include',
            headers: { 'Authorization': __authHeader }
        });
        
        if (response.ok) {
            const data = await response.json();
            __rights = data.rights || {};
            __configVersion = data.config_version || 0;
            
            // Properly hide and clean up the modal
            const modalEl = document.getElementById('loginModal');
            if (modalEl) {
                const modalInstance = bootstrap.Modal.getInstance(modalEl) || new bootstrap.Modal(modalEl);
                modalInstance.hide();
                
                // Wait for modal to finish hiding, then clean up
                setTimeout(() => {
                    // Remove any lingering backdrops
                    document.querySelectorAll('.modal-backdrop').forEach(el => el.remove());
                    document.body.classList.remove('modal-open');
                    document.body.style.overflow = '';
                    document.body.style.paddingRight = '';
                    modalEl.style.display = 'none';
                    modalEl.setAttribute('aria-hidden', 'true');
                    modalEl.classList.remove('show');
                }, 300);
            }
            
            const loginBtn = document.getElementById('login-btn');
            const logoutBtn = document.getElementById('logout-btn');
            if (loginBtn) loginBtn.classList.add('d-none');
            if (logoutBtn) logoutBtn.classList.remove('d-none');
            // Show config link if user has manage_config or modify_layout rights
            if (__rights.manage_config || __rights.modify_layout) {
                const cfg = document.getElementById('config-link');
                if (cfg) cfg.classList.remove('d-none');
            }
            showNotification('Login successful', 'success');
            applyRights();
            // Show reset layout button after login
            const resetBtn = document.getElementById('reset-layout-btn');
            if (resetBtn) resetBtn.classList.remove('d-none');
            // Reload user-specific layout and widgets
            loadDashboardLayout();
            loadCustomWidgets();
            initResizableTables();
            syncAuthButtons();
            initSidebarResizer();
            initMobileCollapsible();
            updateServiceStatus();
        } else {
            document.getElementById('login-error').textContent = 'Invalid credentials';
            document.getElementById('login-error').style.display = 'block';
            __authHeader = null;
        }
    } catch (error) {
        const le = document.getElementById('login-error');
        if (le) {
            le.textContent = 'Login failed: ' + error.message;
            le.style.display = 'block';
        }
        __authHeader = null;
    }
});

function getAuthHeaders() {
    // Fallback: restore authHeader from cookie if missing
    if (!__authHeader) {
        try {
            const match = document.cookie.match(/(?:^|; )authHeader=([^;]+)/);
            if (match) {
                __authHeader = decodeURIComponent(match[1]);
            }
        } catch (e) {}
    }
    const headers = __authHeader ? { 'Authorization': __authHeader } : {};
    if (__csrfToken) {
        headers['X-CSRFToken'] = __csrfToken;
    }
    return headers;
}

// Drag & Drop for Dashboard Modules with Visual Indicators
// GridStack.js integration for drag-drop dashboard layout
let gridStack = null;

function initDragAndDrop() {
    // Initialize GridStack only if not already initialized
    if (gridStack) return;
    
    const gridContainer = document.getElementById('dashboard-grid');
    if (!gridContainer) {
        console.warn('Dashboard grid container not found');
        return;
    }
    
    if (typeof GridStack === 'undefined') {
        console.warn('GridStack not available, falling back to basic layout. Check if gridstack-all.js loaded correctly.');
        return;
    }
    
    // Initialize GridStack
    gridStack = GridStack.init({
        cellHeight: 'auto',
        column: 12,
        float: false,
        animate: true,
        alwaysShowResizeHandle: /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent),
        resizable: {
            handles: 'e, se, s, sw, w'
        },
        handle: '.card-header',
        draggable: {
            scroll: true,
            appendTo: 'body',
            cancel: '.no-drag'
        }
    }, gridContainer);
    
    // Convert existing modules to GridStack items
    const modules = gridContainer.querySelectorAll('.dashboard-module');
    modules.forEach((module, index) => {
        // Determine width based on module class
        let width = 6; // Default: half width
        if (module.classList.contains('wide')) {
            width = 12; // Full width
        } else if (module.classList.contains('narrow')) {
            width = 3; // Quarter width
        }
        
        // Add GridStack attributes
        module.setAttribute('gs-w', width);
        module.setAttribute('gs-h', '1');
        module.setAttribute('gs-auto-position', 'true');
        
        // Make the module a grid item
        gridStack.makeWidget(module);
    });
    
    // Save layout on change
    gridStack.on('change', function(event, items) {
        saveDashboardLayout();
    });
    
    console.log('GridStack initialized with', modules.length, 'modules');
}

async function saveDashboardLayout() {
    if (!gridStack) {
        console.debug('GridStack not initialized, skipping save');
        return;
    }
    
    // Get all grid items with their positions
    const items = gridStack.save(false);  // false = don't include content
    const layout = items.map(item => ({
        module: item.el.dataset.module,
        x: item.x,
        y: item.y,
        w: item.w,
        h: item.h
    })).filter(item => item.module);
    
    localStorage.setItem('dashboardLayout_' + (__authHeader || 'default'), JSON.stringify(layout));
    
    // Also persist to server
    try {
        await fetch('/api/dashboard/layout', {
            method: 'POST',
            credentials: 'include',
            headers: { ...getAuthHeaders(), 'Content-Type': 'application/json' },
            body: JSON.stringify({
                grid_layout: layout,
                hidden_sections: getHiddenModulesList(),
                custom_widgets: getCustomWidgetsList()
            })
        });
    } catch (e) { console.debug('Failed to persist layout to server:', e); }
}

async function loadDashboardLayout() {
    // Try to load from server first
    let layout = null, hidden = null, widgets = null;
    try {
        const resp = await fetch('/api/dashboard/config', {
            credentials: 'include',
            headers: getAuthHeaders()
        });
        if (resp.ok) {
            const data = await resp.json();
            if (data.layout) {
                layout = data.layout.grid_layout || null;
                hidden = data.layout.hidden_sections || null;
                widgets = data.layout.custom_widgets || null;
            }
        }
    } catch (e) { console.debug('Failed to load layout from server:', e); }
    
    // Fallback to localStorage if missing
    if (!layout) {
        const savedLayout = localStorage.getItem('dashboardLayout_' + (__authHeader || 'default'));
        if (savedLayout) {
            try {
                layout = JSON.parse(savedLayout);
            } catch (e) {
                console.warn('Failed to parse saved layout:', e);
            }
        }
    }
    
    // Apply layout to GridStack
    if (layout && gridStack) {
        layout.forEach(item => {
            const module = document.querySelector(`[data-module="${item.module}"]`);
            if (module) {
                gridStack.update(module, {
                    x: item.x,
                    y: item.y,
                    w: item.w,
                    h: item.h
                });
            }
        });
    }
    
    // Restore hidden modules
    if (hidden) {
        hidden.forEach(moduleId => {
            const module = document.querySelector(`[data-module="${moduleId}"]`);
            if (module) module.classList.add('hidden');
        });
    }
    
    // Restore custom widgets
    if (widgets) {
        restoreCustomWidgets(widgets);
    }
}

function resetDashboardLayout() {
    if (confirm('Reset dashboard to default layout? This will reload the page and restore all settings.')) {
        localStorage.removeItem('dashboardLayout_' + (__authHeader || 'default'));
        localStorage.removeItem('hiddenModules_' + (__authHeader || 'default'));
        localStorage.removeItem('customWidget_' + (__authHeader || 'default'));
        
        // Reset GridStack to default positions
        if (gridStack) {
            const modules = document.querySelectorAll('.dashboard-module');
            modules.forEach((module, index) => {
                const width = module.classList.contains('wide') ? 12 : 6;
                gridStack.update(module, {
                    x: (index % 2) * 6,
                    y: Math.floor(index / 2),
                    w: width,
                    h: 1
                });
            });
        }
        location.reload();
    }
}

// Custom Widget Functions
// Custom Widget Functions - Multiple widgets support
let customWidgetCounter = 0;

function addCustomWidget() {
    const container = document.getElementById('custom-widgets-container');
    if (!container) return;
    
    customWidgetCounter++;
    const widgetId = 'custom-widget-' + customWidgetCounter;
    
    const widgetHtml = `
        <div class="dashboard-module" data-module="${widgetId}" draggable="true">
            <div class="card">
                <div class="card-header d-flex align-items-center">
                    <b>Custom Widget ${customWidgetCounter}</b>
                    <button class="btn btn-sm btn-primary ms-2" onclick="editCustomWidget('${widgetId}')">
                        <i class="bi bi-pencil"></i> Edit
                    </button>
                    <span class="hide-toggle" onclick="removeCustomWidget('${widgetId}')" title="Remove widget"><i class="bi bi-trash"></i></span>
                    <span class="drag-handle ms-auto"><i class="bi bi-grip-vertical"></i></span>
                </div>
                <div class="card-body p-3 custom-widget-content" id="${widgetId}-content">
                    <p class="text-muted text-center mb-0">Click Edit to add custom content, embeds, or widgets</p>
                </div>
            </div>
        </div>
    `;
    
    container.insertAdjacentHTML('beforeend', widgetHtml);
    saveCustomWidgets();
    initDragAndDrop(); // Re-init drag for new widget
}

function editCustomWidget(widgetId) {
    const content = document.getElementById(widgetId + '-content');
    if (!content) return;
    
    const currentHtml = content.innerHTML;
    const newHtml = prompt('Enter custom HTML, embed code, or text:\n\n(Tip: You can use iframes, images, or any HTML)', currentHtml);
    
    if (newHtml !== null) {
        content.innerHTML = newHtml;
        saveCustomWidgets();
    }
}

function removeCustomWidget(widgetId) {
    if (!confirm('Remove this widget?')) return;
    const widget = document.querySelector(`[data-module="${widgetId}"]`);
    if (widget) {
        widget.remove();
        saveCustomWidgets();
    }
}

async function saveCustomWidgets() {
    const container = document.getElementById('custom-widgets-container');
    if (!container) return;
    const widgets = getCustomWidgetsList();
    localStorage.setItem('customWidgets_' + (__authHeader || 'default'), JSON.stringify(widgets));
    // Also persist to server
    try {
        await fetch('/api/dashboard/layout', {
            method: 'POST',
            credentials: 'include',
            headers: { ...getAuthHeaders(), 'Content-Type': 'application/json' },
            body: JSON.stringify({
                custom_widgets: widgets
            })
        });
    } catch (e) { console.warn('Failed to persist widgets to server:', e); }
}

async function loadCustomWidgets() {
    // Try to load from server first
    let widgets = null;
    try {
        const resp = await fetch('/api/dashboard/config', {
            credentials: 'include',
            headers: getAuthHeaders()
        });
        if (resp.ok) {
            const data = await resp.json();
            if (data.layout && data.layout.custom_widgets) {
                widgets = data.layout.custom_widgets;
            }
        }
    } catch (e) { console.warn('Failed to load widgets from server:', e); }
    // Fallback to localStorage if missing
    if (!widgets) {
        const saved = localStorage.getItem('customWidgets_' + (__authHeader || 'default'));
        if (saved) widgets = JSON.parse(saved);
    }
    restoreCustomWidgets(widgets);
}

function restoreCustomWidgets(widgets) {
    if (!widgets) return;
    const container = document.getElementById('custom-widgets-container');
    if (!container) return;
    container.innerHTML = '';
    widgets.forEach(widget => {
        const widgetNum = widget.id.replace('custom-widget-', '');
        customWidgetCounter = Math.max(customWidgetCounter, parseInt(widgetNum) || 0);
        const widgetHtml = `
            <div class="dashboard-module" data-module="${widget.id}" draggable="true">
                <div class="card">
                    <div class="card-header d-flex align-items-center">
                        <b>Custom Widget ${widgetNum}</b>
                        <button class="btn btn-sm btn-primary ms-2" onclick="editCustomWidget('${widget.id}')">
                            <i class="bi bi-pencil"></i> Edit
                        </button>
                        <span class="hide-toggle" onclick="removeCustomWidget('${widget.id}')" title="Remove widget"><i class="bi bi-trash"></i></span>
                        <span class="drag-handle ms-auto"><i class="bi bi-grip-vertical"></i></span>
                    </div>
                    <div class="card-body p-3 custom-widget-content" id="${widget.id}-content">
                        ${widget.html}
                    </div>
                </div>
            </div>
        `;
        container.insertAdjacentHTML('beforeend', widgetHtml);
    });
    initDragAndDrop();
}

function getCustomWidgetsList() {
    const container = document.getElementById('custom-widgets-container');
    if (!container) return [];
    const widgets = [];
    container.querySelectorAll('.dashboard-module').forEach(widget => {
        const id = widget.dataset.module;
        const content = document.getElementById(id + '-content');
        if (content) {
            widgets.push({ id, html: content.innerHTML });
        }
    });
    return widgets;
}

function getHiddenModulesList() {
    return Array.from(document.querySelectorAll('.dashboard-module.hidden')).map(el => el.dataset.module).filter(m => m);
}
// Resizable Table Columns
function makeTableResizable(table) {
    if (!table || table.classList.contains('resizable-init')) return;
    table.classList.add('resizable-table', 'resizable-init');
    
    const thead = table.querySelector('thead');
    if (!thead) return;
    
    const headers = thead.querySelectorAll('th');
    headers.forEach((th, index) => {
        // Skip last column
        if (index === headers.length - 1) return;
        
        const handle = document.createElement('div');
        handle.className = 'resize-handle';
        th.style.position = 'relative';
        th.appendChild(handle);
        
        let startX, startWidth, targetTh;
        
        handle.addEventListener('mousedown', function(e) {
            e.preventDefault();
            targetTh = this.parentElement;
            startX = e.pageX;
            startWidth = targetTh.offsetWidth;
            
            handle.classList.add('active');
            document.body.style.cursor = 'col-resize';
            document.body.style.userSelect = 'none';
            
            document.addEventListener('mousemove', onMouseMove);
            document.addEventListener('mouseup', onMouseUp);
        });
        
        function onMouseMove(e) {
            if (!targetTh) return;
            const diff = e.pageX - startX;
            const newWidth = Math.max(50, startWidth + diff);
            targetTh.style.width = newWidth + 'px';
            targetTh.style.minWidth = newWidth + 'px';
        }
        
        function onMouseUp() {
            handle.classList.remove('active');
            document.body.style.cursor = '';
            document.body.style.userSelect = '';
            document.removeEventListener('mousemove', onMouseMove);
            document.removeEventListener('mouseup', onMouseUp);
            targetTh = null;
        }
    });
}

// Make all tables resizable
function initResizableTables() {
    document.querySelectorAll('.dashboard-module table, .config-module table').forEach(table => {
        makeTableResizable(table);
    });
}

// Sync sidebar buttons with main buttons
function syncAuthButtons() {
    const loginBtn = document.getElementById('login-btn');
    const logoutBtn = document.getElementById('logout-btn');
    const configLink = document.getElementById('config-link');
    
    const loginBtnSidebar = document.getElementById('login-btn-sidebar');
    const logoutBtnSidebar = document.getElementById('logout-btn-sidebar');
    const configLinkSidebar = document.getElementById('config-link-sidebar');
    
    if (loginBtn && loginBtnSidebar) {
        if (loginBtn.classList.contains('d-none')) {
            loginBtnSidebar.classList.add('d-none');
        } else {
            loginBtnSidebar.classList.remove('d-none');
        }
    }
    
    if (logoutBtn && logoutBtnSidebar) {
        if (logoutBtn.classList.contains('d-none')) {
            logoutBtnSidebar.classList.add('d-none');
        } else {
            logoutBtnSidebar.classList.remove('d-none');
        }
    }
    
    if (configLink && configLinkSidebar) {
        if (configLink.classList.contains('d-none')) {
            configLinkSidebar.classList.add('d-none');
        } else {
            configLinkSidebar.classList.remove('d-none');
        }
    }
    
    // Ensure sidebar button onclicks are wired even if DOM updated
    if (loginBtnSidebar) loginBtnSidebar.onclick = promptLogin;
    if (logoutBtnSidebar) logoutBtnSidebar.onclick = logout;
}
    syncAuthButtons();

// Hide/Show Module Functions
// ⚠️ DEPRECATED: Module hide/show is now managed by Alpine.js
// Module visibility state is stored in Alpine reactive data (x-data) and localStorage
// See: dash/dashboard.html - dashboard-grid Alpine.js setup

// LEGACY: Replaced by Alpine.js x-show directive and @click handlers
function toggleHideModule(moduleId) {
    console.warn('toggleHideModule() is deprecated - Alpine.js manages module visibility');
}

// LEGACY: Replaced by Alpine.js reactivity
function saveHiddenModules() {
    console.warn('saveHiddenModules() is deprecated - Alpine.js handles persistence automatically');
}

// LEGACY: Replaced by Alpine.js on init
function loadHiddenModules() {
    console.warn('loadHiddenModules() is deprecated - Alpine.js loads state from localStorage automatically');
}

// LEGACY: Replaced by Alpine.js button with x-show
function showHiddenModules() {
    console.warn('showHiddenModules() is deprecated - use Alpine.js show-all-button instead');
}

// LEGACY: Replaced by Alpine.js reactive count
function updateShowHiddenButton() {
    console.warn('updateShowHiddenButton() is deprecated - Alpine.js updates UI reactively');
}

// Public IP obfuscation
let __publicIP = '•••.•••.•••.•••';
let __publicIPRevealed = false;

// Public IP Extraction from IPChicken
function extractPublicIP() {
    try {
        const iframe = document.getElementById('ipchicken-frame');
        const iframeDoc = iframe.contentDocument || iframe.contentWindow.document;
        const bodyText = iframeDoc.body.innerText || iframeDoc.body.textContent;
        
        // IPChicken displays IP in format like "Current IP Address: X.X.X.X"
        const ipMatch = bodyText.match(/\b(?:\d{1,3}\.){3}\d{1,3}\b/);
        
        if (ipMatch) {
            __publicIP = ipMatch[0];
        } else {
            __publicIP = 'Unable to detect';
        }
    } catch (e) {
        // CORS issue - fallback to API
        fetch('https://api.ipify.org?format=json')
            .then(response => response.json())
            .then(data => {
                __publicIP = data.ip;
            })
            .catch(() => {
                __publicIP = 'Unavailable';
            });
    }
}

function revealPublicIP() {
    if (!__publicIPRevealed && __publicIP) {
        document.getElementById('public-ip-display').textContent = __publicIP;
        __publicIPRevealed = true;
    }
}

function hidePublicIP() {
    if (__publicIPRevealed) {
        document.getElementById('public-ip-display').textContent = '•••.•••.•••.•••';
        __publicIPRevealed = false;
    }
}

function copyPublicIP(el) {
    if (__publicIP && __publicIP !== '•••.•••.•••.•••') {
        copyToClipboard(__publicIP, el);
    } else {
        showNotification('Public IP not yet loaded', 'warning');
    }
}
// Export public IP helpers to global for inline handlers and iframe load
window.extractPublicIP = extractPublicIP;
window.revealPublicIP = revealPublicIP;
window.hidePublicIP = hidePublicIP;
window.copyPublicIP = copyPublicIP;

// Ensure these functions are globally accessible for inline event handlers
window.revealPublicIP = revealPublicIP;
window.hidePublicIP = hidePublicIP;
window.copyPublicIP = copyPublicIP;

// Generic copy to clipboard with visual feedback
function copyToClipboard(text, el) {
    navigator.clipboard.writeText(text).then(() => {
        const original = el.textContent;
        el.textContent = '✓ Copied!';
        el.style.color = '#28a745';
        setTimeout(() => {
            el.textContent = original;
            el.style.color = '';
        }, 1500);
        showNotification('Copied to clipboard', 'success');
    }).catch(() => {
        showNotification('Failed to copy', 'danger');
    });
}
window.copyToClipboard = copyToClipboard;

// Dev Reset to Setup
function devResetToSetup() {
    if (!confirm('⚠️ WARNING: This will DELETE all config, users, passwords, and state files.\n\nThis will force the setup wizard on next page load.\n\nAre you sure?')) {
        return;
    }
    fetch('/dev/reset-to-setup', { method: 'POST' })
        .then(r => r.json())
        .then(data => {
            if (data.success) {
                showNotification('Reset complete! Reloading...', 'success');
                setTimeout(() => { window.location.href = '/'; }, 1500);
            } else {
                showNotification('Reset failed: ' + (data.error || 'Unknown error'), 'danger');
            }
        })
        .catch(err => {
            showNotification('Error: ' + err.message, 'danger');
        });
}

// --- Column width preferences for Custom Routes and Tag Routes ---
function setColWidth(prefix, col, pct) {
    const el = document.getElementById(`${prefix}-${col}-col`);
    if (el) el.style.width = `${pct}%`;
}

function applyColumnPrefs(prefix, cols) {
    cols.forEach(col => {
        const key = `dor_${prefix}_${col}_width_pct`;
        const val = localStorage.getItem(key);
        if (val) {
            const pct = parseInt(val, 10);
            setColWidth(prefix, col, pct);
            // Also update slider if present
            const slider = document.getElementById(`${prefix}-${col}-width`);
            if (slider) slider.value = pct;
        }
    });
}

function hookColumnSliders(prefix, cols) {
    cols.forEach(col => {
        const slider = document.getElementById(`${prefix}-${col}-width`);
        if (!slider) return;
        slider.addEventListener('input', (e) => {
            const pct = parseInt(e.target.value, 10);
            setColWidth(prefix, col, pct);
        });
    });
}

function saveCustomRoutesColumnPrefs() {
    saveColumnPrefs('cr', ['ext','folder','action']);
}

function saveTagRoutesColumnPrefs() {
    saveColumnPrefs('tr', ['tag','folder','action']);
}

// Load organizer config and apply feature gating
async function loadOrganizerConfig() {
    try {
        const resp = await fetch('/api/organizer/config', {
            credentials: 'include',
            cache: 'no-store',
            headers: getAuthHeaders()
        });
        if (!resp.ok) return;
        const cfg = await resp.json();
        const features = cfg.features || {};
        __organizerFeatures = {
            virustotal_enabled: features.virustotal_enabled !== false,
            duplicates_enabled: features.duplicates_enabled !== false,
            reports_enabled: features.reports_enabled !== false
        };
        __vtApiKey = cfg.vt_api_key || cfg.virustotal_api_key || '';
        // Expose to window for template string evaluation
        window.__organizerFeatures = __organizerFeatures;
        window.__vtApiKey = __vtApiKey;
        console.log('VT Config:', { enabled: __organizerFeatures.virustotal_enabled, hasKey: !!__vtApiKey });
        applyFeatureGating();
    } catch (e) {
        console.warn('Failed to load organizer config:', e);
    }
}

function applyFeatureGating() {
    // Duplicates gating
    const dupBanner = document.getElementById('duplicates-disabled-banner');
    const dupBody = document.getElementById('duplicates-body');
    if (dupBanner && dupBody) {
        if (!__organizerFeatures.duplicates_enabled) {
            dupBanner.classList.remove('d-none');
            dupBody.style.display = 'none';
            const b = document.getElementById('badge-duplicates-state');
            if (b) { b.textContent = 'Off'; b.className = 'badge bg-secondary ms-2'; }
        } else {
            dupBanner.classList.add('d-none');
            dupBody.style.display = '';
            const b = document.getElementById('badge-duplicates-state');
            if (b) { b.textContent = 'On'; b.className = 'badge bg-success ms-2'; }
        }
    }
    // Reports/statistics gating
    const repBanner = document.getElementById('reports-disabled-banner');
    const statsBody = document.getElementById('statistics-body');
    if (repBanner && statsBody) {
        if (!__organizerFeatures.reports_enabled) {
            repBanner.classList.remove('d-none');
            statsBody.style.display = 'none';
            const b = document.getElementById('badge-reports-state');
            if (b) { b.textContent = 'Off'; b.className = 'badge bg-secondary ms-2'; }
        } else {
            repBanner.classList.add('d-none');
            statsBody.style.display = '';
            const b = document.getElementById('badge-reports-state');
            if (b) { b.textContent = 'On'; b.className = 'badge bg-success ms-2'; }
        }
    }
    // Virustotal gating in recent files (button visibility)
    const vtButtons = document.querySelectorAll('[data-action="vt-scan"]');
    vtButtons.forEach(btn => {
        const enabled = __organizerFeatures.virustotal_enabled && !!__vtApiKey;
        btn.style.display = enabled ? '' : 'none';
        if (!enabled) btn.title = 'VirusTotal disabled or API key missing';
    });
}

function applyRights() {
    document.querySelectorAll('[data-right]').forEach(el => {
        const need = el.getAttribute('data-right');
        if (!__rights[need]) {
            // Graceful message instead of hiding
            const collapses = el.querySelectorAll('.collapse');
            collapses.forEach(c => {
                c.innerHTML = `<div class="ps-2 pe-2 pt-2 pb-1"><small class="text-muted">You lack rights (<code>${need}</code>) to view this section.</small></div>`;
            });
        }
    });
    // Service buttons gating
    if (!__rights.manage_service) {
        document.querySelectorAll('#collapseServiceStatus button').forEach(b => {
            b.disabled = true;
            b.title = 'Insufficient rights (manage_service)';
        });
    }
    // Config save gating
    if (!__rights.manage_config) {
        const cfgBtn = document.querySelector('#config-form button.btn-primary');
        if (cfgBtn) {
            cfgBtn.disabled = true;
            cfgBtn.title = 'Insufficient rights (manage_config)';
        }
        const setBtn = document.querySelector('#config-form-settings button.btn-primary');
        if (setBtn) {
            setBtn.disabled = true;
            setBtn.title = 'Insufficient rights (manage_config)';
        }
    }
    // Call page-specific rights application if available (e.g., for config page)
    if (typeof applyConfigRights === 'function') {
        applyConfigRights();
    }
}

// Poll rights periodically to detect config changes
async function pollRights() {
    if (!__authHeader) return; // only when logged in
    try {
        const resp = await fetch('/auth/session', { headers: getAuthHeaders(), credentials: 'include' });
        if (!resp.ok) return;
        const data = await resp.json();
        const newVersion = data.config_version || 0;
        if (newVersion !== __configVersion) {
            __configVersion = newVersion;
            __rights = data.rights || {};
            applyRights();
            if (__rights.view_metrics) updateServiceStatus();
            if (__rights.view_recent_files) refreshRecentFiles();
        }
    } catch (e) {
        // Silent failures acceptable
    }
}

// Service Control Functions - MIGRATED TO HTMX
// Service control buttons now use htmx attributes directly in HTML
// See dash/dashboard.html service control buttons for implementation
// Benefits: 90% less code, automatic error handling, built-in loading states

// Legacy updateServiceStatus removed - now handled by htmx event trigger
// Status updates triggered via: htmx.trigger('#service-badge-sidebar','refresh-status')

// Fetch configured service name from server and display in header
async function fetchServiceName() {
    try {
        const resp = await fetch('/service_name');
        if (!resp.ok) return;
        const data = await resp.json();
        const name = data.service_name || '';
        const el = document.getElementById('service-name');
        const btn = document.getElementById('service-name-btn');
        if (el) el.textContent = name;
        if (btn) btn.style.display = name ? 'inline-block' : 'none';
    } catch (err) {
        console.error('Failed to fetch service name:', err);
    }
}

function copyServiceName() {
    const el = document.getElementById('service-name');
    if (!el) return;
    const name = el.textContent || '';
    if (!name) return;
    navigator.clipboard?.writeText(name).then(() => {
        showNotification('Service name copied to clipboard', 'success');
    }).catch(() => {
        showNotification('Failed to copy service name', 'warning');
    });
}

// Configuration Save
async function saveConfiguration() {
    const catForm = document.getElementById('config-form');
    const customForm = document.getElementById('custom-routes-form');
    const catData = new FormData(catForm);
    const customData = new FormData(customForm);
    
    // Build routes dict from category form
    const routes = {};
    let i = 1;
    let foundAny = true;
    while (foundAny) {
        const folder = catData.get(`folder_${i}`);
        const exts = catData.get(`exts_${i}`);
        if (folder !== null && exts !== null) {
            const list = (exts || '').split(',').map(s => s.trim()).filter(Boolean);
            if (folder.trim()) routes[folder.trim()] = list;
            i++;
        } else {
            foundAny = false;
        }
    }

    // Build custom_routes dict from custom form
    const custom_routes = {};
    if (customForm) {
        let j = 1;
        let foundAny = true;
        while (foundAny) {
            const ext = customData.get(`ext_${j}`);
            const path = customData.get(`path_${j}`);
            if (ext !== null || path !== null) {
                if (ext && path && ext.trim() && path.trim()) {
                    custom_routes[ext.trim()] = path.trim();
                }
                j++;
            } else {
                foundAny = false;
            }
        }
    }

    // Build tag_routes dict from tag form
    const tagForm = document.getElementById('tag-routes-form');
    const tag_routes = {};
    if (tagForm) {
        const tagData = new FormData(tagForm);
        let k = 1;
        let foundAny = true;
        while (foundAny) {
            const tag = tagData.get(`tag_${k}`);
            const tagpath = tagData.get(`tagpath_${k}`);
            if (tag !== null || tagpath !== null) {
                if (tag && tagpath && tag.trim() && tagpath.trim()) {
                    tag_routes[tag.trim()] = tagpath.trim();
                }
                k++;
            } else {
                foundAny = false;
            }
        }
    }

    // Prepare JSON payload
    const payload = {
        routes,
        custom_routes,
        tag_routes
    };
    
    try {
        if (!__authHeader) {
            showNotification('Please login before saving configuration', 'warning');
            return;
        }
        const response = await fetch('/api/update', {
            method: 'POST',
            body: JSON.stringify(payload),
            credentials: 'include',
            headers: { ...getAuthHeaders(), 'Content-Type': 'application/json' }
        });
        if (response.ok) {
            const result = await response.json();
            showNotification(result.message || 'Configuration saved successfully', 'success');
            // Reload the configuration to show the saved data
            await initializeCustomRoutes();
            
            // Ask if user wants to restart the service to apply changes
            if (confirm('Configuration saved! Would you like to restart the Organizer service now to apply the changes?')) {
                try {
                    const restartResponse = await fetch('/restart', {
                        method: 'POST',
                        credentials: 'include',
                        headers: getAuthHeaders()
                    });
                    if (restartResponse.ok) {
                        showNotification('Service restarted successfully. File organization will resume momentarily.', 'success');
                    } else {
                        showNotification('Failed to restart service. Please restart manually.', 'warning');
                    }
                } catch (err) {
                    showNotification('Error restarting service: ' + err.message, 'warning');
                }
            } else {
                showNotification('Remember to restart the service manually for changes to take effect.', 'info');
            }
        } else {
            const t = await response.text();
            showNotification('Failed to save configuration: ' + t.substring(0,200), 'danger');
        }
    } catch (error) {
        showNotification(`Error: ${error.message}`, 'danger');
    }
}

async function saveSettings() {
    const form = document.getElementById('config-form-settings');
    const formData = new FormData(form);
    
    try {
        if (!__authHeader) {
            showNotification('Please login before saving settings', 'warning');
            return;
        }
        const response = await fetch('/api/update', {
            method: 'POST',
            body: formData,
            credentials: 'include',
            headers: getAuthHeaders()
        });
        if (response.ok) {
            const result = await response.json();
            showNotification(result.message || 'Settings saved successfully', 'success');
            
            // Check if watch_folder was changed
            const watchFolder = formData.get('watch_folder');
            if (watchFolder) {
                // Ask if user wants to restart the service to apply watch folder change
                if (confirm('Watch folder setting saved! Would you like to restart the Organizer service now to apply the changes?')) {
                    try {
                        const restartResponse = await fetch('/restart', {
                            method: 'POST',
                            credentials: 'include',
                            headers: getAuthHeaders()
                        });
                        if (restartResponse.ok) {
                            showNotification('Service restarted successfully. Now monitoring: ' + watchFolder, 'success');
                        } else {
                            showNotification('Failed to restart service. Please restart manually.', 'warning');
                        }
                    } catch (err) {
                        showNotification('Error restarting service: ' + err.message, 'warning');
                    }
                } else {
                    showNotification('Remember to restart the service manually for watch folder changes to take effect.', 'info');
                }
            }
        } else {
            showNotification('Failed to save settings', 'danger');
        }
    } catch (error) {
        showNotification(`Error: ${error.message}`, 'danger');
    }
}

// UNC Credentials Management Functions
let __uncCurrentPath = '';

function showUNCCredentialsModal() {
    const watchFolderInput = document.getElementById('watch_folder');
    const path = watchFolderInput.value.trim();
    
    if (!path) {
        showNotification('Please enter a watch folder path first', 'warning');
        return;
    }
    
    __uncCurrentPath = path;
    
    // Validate UNC syntax
    validateUNCSyntax(path);
}

async function validateUNCSyntax(path) {
    try {
        const response = await fetch('/api/unc/validate-syntax', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                ...getAuthHeaders()
            },
            credentials: 'include',
            body: JSON.stringify({ unc_path: path })
        });
        
        if (response.ok) {
            const result = await response.json();
            if (result.valid) {
                // Load existing credentials if any
                loadUNCCredentials(path);
            } else {
                clearUNCFields();
                showUNCError(result.message || 'Invalid UNC path format');
            }
        } else {
            const error = await response.json();
            showUNCError(error.error || 'Failed to validate UNC path');
        }
    } catch (error) {
        showUNCError(`Validation error: ${error.message}`);
    }
}

async function loadUNCCredentials(path) {
    try {
        const response = await fetch(`/api/unc/get-credentials/${encodeURIComponent(path)}`, {
            headers: getAuthHeaders(),
            credentials: 'include'
        });
        
        if (response.ok) {
            const result = await response.json();
            const creds = result.credentials || {};
            
            document.getElementById('unc-path-display').value = path;
            document.getElementById('unc-username').value = creds.username || '';
            document.getElementById('unc-password').value = ''; // Never pre-fill password for security
            document.getElementById('unc-domain').value = creds.domain || '';
            document.getElementById('unc-hostname').value = creds.hostname || '';
            document.getElementById('unc-auth-type').value = creds.auth_type || 'windows';
            
            updateUNCAuthFields();
            clearUNCMessage();
            
            const modal = new bootstrap.Modal(document.getElementById('uncCredsModal'));
            modal.show();
        } else {
            // No existing credentials, initialize fresh form
            document.getElementById('unc-path-display').value = path;
            document.getElementById('unc-username').value = '';
            document.getElementById('unc-password').value = '';
            document.getElementById('unc-domain').value = '';
            document.getElementById('unc-hostname').value = '';
            document.getElementById('unc-auth-type').value = 'windows';
            
            updateUNCAuthFields();
            clearUNCMessage();
            
            const modal = new bootstrap.Modal(document.getElementById('uncCredsModal'));
            modal.show();
        }
    } catch (error) {
        showUNCError(`Error loading credentials: ${error.message}`);
    }
}

function updateUNCAuthFields() {
    const authType = document.getElementById('unc-auth-type').value;
    const windowsFields = document.getElementById('windows-auth-fields');
    
    if (authType === 'windows') {
        windowsFields.style.display = 'block';
    } else {
        windowsFields.style.display = 'none';
    }
}

async function testUNCCredentials() {
    const path = document.getElementById('unc-path-display').value;
    const username = document.getElementById('unc-username').value;
    const password = document.getElementById('unc-password').value;
    const domain = document.getElementById('unc-domain').value;
    const hostname = document.getElementById('unc-hostname').value;
    const authType = document.getElementById('unc-auth-type').value;
    
    if (!path || !username || !password) {
        showUNCError('Username and password are required');
        return;
    }
    
    const testBtn = document.getElementById('btn-test-unc');
    testBtn.disabled = true;
    testBtn.innerHTML = '<span class="spinner-border spinner-border-sm me-2"></span>Testing...';
    
    try {
        const response = await fetch('/api/unc/test-credentials', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                ...getAuthHeaders()
            },
            credentials: 'include',
            body: JSON.stringify({
                unc_path: path,
                username: username,
                password: password,
                domain: domain,
                hostname: hostname,
                auth_type: authType
            })
        });
        
        if (response.ok) {
            const result = await response.json();
            showUNCMessage('✓ Connection successful! You can now save these credentials.', 'success');
        } else {
            const error = await response.json();
            showUNCError(error.error || 'Connection failed');
        }
    } catch (error) {
        showUNCError(`Test error: ${error.message}`);
    } finally {
        testBtn.disabled = false;
        testBtn.innerHTML = '<i class="bi bi-plug"></i> Test Connection';
    }
}

async function saveUNCCredentials() {
    const path = document.getElementById('unc-path-display').value;
    const username = document.getElementById('unc-username').value;
    const password = document.getElementById('unc-password').value;
    const domain = document.getElementById('unc-domain').value;
    const hostname = document.getElementById('unc-hostname').value;
    const authType = document.getElementById('unc-auth-type').value;
    
    if (!path || !username || !password) {
        showUNCError('Username and password are required');
        return;
    }
    
    const saveBtn = document.getElementById('btn-save-unc');
    saveBtn.disabled = true;
    saveBtn.innerHTML = '<span class="spinner-border spinner-border-sm me-2"></span>Saving...';
    
    try {
        const response = await fetch('/api/unc/save-credentials', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                ...getAuthHeaders()
            },
            credentials: 'include',
            body: JSON.stringify({
                unc_path: path,
                username: username,
                password: password,
                domain: domain || undefined,
                hostname: hostname || undefined,
                auth_type: authType
            })
        });
        
        if (response.ok) {
            const result = await response.json();
            showUNCMessage('✓ Credentials saved successfully!', 'success');
            setTimeout(() => {
                bootstrap.Modal.getInstance(document.getElementById('uncCredsModal')).hide();
                showNotification(`Credentials saved for ${path}`, 'success');
            }, 1000);
        } else {
            const error = await response.json();
            showUNCError(error.error || 'Failed to save credentials');
        }
    } catch (error) {
        showUNCError(`Save error: ${error.message}`);
    } finally {
        saveBtn.disabled = false;
        saveBtn.innerHTML = '<i class="bi bi-save"></i> Save Credentials';
    }
}

function clearUNCFields() {
    document.getElementById('unc-path-display').value = '';
    document.getElementById('unc-username').value = '';
    document.getElementById('unc-password').value = '';
    document.getElementById('unc-domain').value = '';
    document.getElementById('unc-hostname').value = '';
    document.getElementById('unc-auth-type').value = 'windows';
}

function clearUNCMessage() {
    document.getElementById('unc-message').style.display = 'none';
    document.getElementById('unc-message').innerHTML = '';
    document.getElementById('unc-error').style.display = 'none';
    document.getElementById('unc-error').innerHTML = '';
}

function showUNCMessage(msg, type) {
    const msgDiv = document.getElementById('unc-message');
    msgDiv.className = 'alert alert-sm py-1 px-2 mb-2';
    msgDiv.className += type === 'success' ? ' alert-success' : ' alert-info';
    msgDiv.innerHTML = msg;
    msgDiv.style.display = 'block';
    document.getElementById('unc-error').style.display = 'none';
}

function showUNCError(msg) {
    const errDiv = document.getElementById('unc-error');
    errDiv.innerHTML = '<i class="bi bi-exclamation-circle"></i> ' + msg;
    errDiv.style.display = 'block';
    document.getElementById('unc-message').style.display = 'none';
}

// Detect UNC path in watch folder input and show credentials button
document.addEventListener('DOMContentLoaded', function() {
    const watchFolderInput = document.getElementById('watch_folder');
    if (watchFolderInput) {
        watchFolderInput.addEventListener('blur', function() {
            const path = this.value.trim();
            const uncWarning = document.getElementById('unc-warning');
            const uncCredsBtn = document.getElementById('btn-unc-creds');
            
            if (path && path.startsWith('\\\\')) {
                uncWarning.style.display = 'block';
                uncCredsBtn.style.display = 'inline-block';
            } else {
                uncWarning.style.display = 'none';
                uncCredsBtn.style.display = 'none';
            }
        });
    }
});

// Initialize form field validation with real-time feedback
function initializeFormValidation(container = document) {
    const inputs = container.querySelectorAll('input[pattern], input[required]');
    inputs.forEach(input => {
        const wrapper = input.closest('.form-validation-wrapper');
        if (!wrapper) return;
        
        const icon = wrapper.querySelector('.form-validation-icon i');
        if (!icon) return;
        
        // Validate on blur
        input.addEventListener('blur', () => {
            const isValid = input.checkValidity();
            const icon = wrapper.querySelector('.form-validation-icon i');
            
            if (isValid && input.value.trim()) {
                wrapper.classList.add('valid');
                wrapper.classList.remove('invalid');
                icon.className = 'bi bi-check-circle-fill';
            } else if (input.value.trim()) {
                wrapper.classList.add('invalid');
                wrapper.classList.remove('valid');
                icon.className = 'bi bi-x-circle-fill';
            } else {
                wrapper.classList.remove('valid', 'invalid');
                icon.className = 'bi';
            }
        });
        
        // Clear error feedback on input
        input.addEventListener('input', () => {
            wrapper.classList.remove('invalid');
            if (input.value.trim()) {
                const isValid = input.checkValidity();
                if (isValid) {
                    wrapper.classList.add('valid');
                    icon.className = 'bi bi-check-circle-fill';
                }
            }
        });
    });
}

// Initialize table sorting for .table-sortable tables
function initializeTableSorting(container = document) {
    const tables = container.querySelectorAll('.table-sortable');
    
    tables.forEach(table => {
        const headers = table.querySelectorAll('thead th');
        const tbody = table.querySelector('tbody');
        if (!tbody) return;
        
        headers.forEach((header, columnIndex) => {
            header.style.cursor = 'pointer';
            header.title = 'Click to sort';
            
            header.addEventListener('click', () => {
                const rows = Array.from(tbody.querySelectorAll('tr'));
                const isAscending = header.dataset.sortOrder !== 'asc';
                
                // Remove previous sort indicators
                headers.forEach(h => {
                    h.dataset.sortOrder = '';
                    const sortSpan = h.querySelector('.sort-indicator');
                    if (sortSpan) sortSpan.textContent = '';
                });
                
                // Sort rows
                rows.sort((a, b) => {
                    const cellA = a.children[columnIndex]?.textContent || '';
                    const cellB = b.children[columnIndex]?.textContent || '';
                    
                    // Try numeric sort first
                    const numA = parseFloat(cellA);
                    const numB = parseFloat(cellB);
                    
                    if (!isNaN(numA) && !isNaN(numB)) {
                        return isAscending ? numA - numB : numB - numA;
                    }
                    
                    // Fall back to string sort
                    return isAscending 
                        ? cellA.localeCompare(cellB)
                        : cellB.localeCompare(cellA);
                });
                
                // Re-append sorted rows
                rows.forEach(row => tbody.appendChild(row));
                
                // Add sort indicator
                header.dataset.sortOrder = isAscending ? 'asc' : 'desc';
                const sortSpan = header.querySelector('.sort-indicator');
                if (sortSpan) {
                    sortSpan.textContent = isAscending ? ' ↑' : ' ↓';
                }
            });
        });
    });
}

function deleteRow(btn) {
    btn.closest('tr').remove();
}

// Add new category row to File Categories table
function addCategoryRow() {
    const tbody = document.querySelector('#config-form tbody');
    const rowCount = tbody.querySelectorAll('tr').length + 1;
    const newRow = document.createElement('tr');
    newRow.innerHTML = `
        <td>
            <div class="form-validation-wrapper">
                <input class="form-control form-control-sm" type="text" name="folder_${rowCount}" placeholder="Folder name" required pattern="^[a-zA-Z0-9_\\-\\s]+$" maxlength="50">
                <span class="form-validation-icon"><i class="bi"></i></span>
            </div>
        </td>
        <td>
            <div class="form-validation-wrapper">
                <input class="form-control form-control-sm" type="text" name="exts_${rowCount}" placeholder="ext1, ext2, ext3" pattern="^[a-zA-Z0-9,\\s\\.]*$" maxlength="200">
                <span class="form-validation-icon"><i class="bi"></i></span>
            </div>
        </td>
        <td><button class="btn btn-danger btn-sm" type="button" onclick="deleteRow(this)">Delete</button></td>
    `;
    tbody.appendChild(newRow);
    initializeFormValidation(newRow);
}

// Add new custom route row to Custom Routes table
function addCustomRouteRow() {
    const tbody = document.getElementById('custom-routes-tbody');
    const rowCount = tbody.querySelectorAll('tr').length + 1;
    const newRow = document.createElement('tr');
    newRow.innerHTML = `
        <td><input class="form-control form-control-sm" type="text" name="ext_${rowCount}" placeholder="mp4"></td>
        <td><input class="form-control form-control-sm" type="text" name="path_${rowCount}" placeholder="C:/Media/Videos"></td>
        <td><button class="btn btn-danger btn-sm" type="button" onclick="deleteRow(this)">Delete</button></td>
    `;
    tbody.appendChild(newRow);
}

// Add new tag route row to Tag Routes table
function addTagRouteRow() {
    const tbody = document.getElementById('tag-routes-tbody');
    const rowCount = tbody.querySelectorAll('tr').length + 1;
    const newRow = document.createElement('tr');
    newRow.innerHTML = `
        <td>
            <div class="form-validation-wrapper">
                <input class="form-control form-control-sm" type="text" name="tag_${rowCount}" placeholder="invoice" required pattern="^[a-zA-Z0-9_\\-\\s]+$" maxlength="50">
                <span class="form-validation-icon"><i class="bi"></i></span>
            </div>
        </td>
        <td>
            <div class="form-validation-wrapper">
                <input class="form-control form-control-sm" type="text" name="tagpath_${rowCount}" placeholder="C:/Documents/Invoices" required maxlength="255">
                <span class="form-validation-icon"><i class="bi"></i></span>
            </div>
        </td>
        <td><button class="btn btn-danger btn-sm" type="button" onclick="deleteRow(this)">Delete</button></td>
    `;
    tbody.appendChild(newRow);
    initializeFormValidation(newRow);
}

// Load custom routes from config on page load
function loadCustomRoutes(customRoutes) {
    const tbody = document.getElementById('custom-routes-tbody');
    if (!tbody) return; // Not on dashboard page
    
    tbody.innerHTML = ''; // Clear existing rows
    
    if (customRoutes && Object.keys(customRoutes).length > 0) {
        let index = 1;
        for (const [ext, path] of Object.entries(customRoutes)) {
            const row = document.createElement('tr');
            row.innerHTML = `
                <td><input class="form-control form-control-sm" type="text" name="ext_${index}" value="${ext}"></td>
                <td><input class="form-control form-control-sm" type="text" name="path_${index}" value="${path}"></td>
                <td><button class="btn btn-danger btn-sm" type="button" onclick="deleteRow(this)">Delete</button></td>
            `;
            tbody.appendChild(row);
            index++;
        }
    }
}

// Initialize custom routes table on page load
async function loadFileCategories(routes) {
    const tbody = document.querySelector('#config-form tbody');
    if (!tbody) return;
    
    // Clear existing rows
    tbody.innerHTML = '';
    
    // Populate rows from config
    let rowNum = 1;
    for (const [folder, extensions] of Object.entries(routes)) {
        const row = document.createElement('tr');
        row.innerHTML = `
            <td>
                <div class="form-validation-wrapper">
                    <input class="form-control form-control-sm" type="text" name="folder_${rowNum}" value="${folder}" required pattern="^[a-zA-Z0-9_\\-\\s]+$" maxlength="50">
                    <span class="form-validation-icon"><i class="bi"></i></span>
                </div>
            </td>
            <td>
                <div class="form-validation-wrapper">
                    <input class="form-control form-control-sm" type="text" name="exts_${rowNum}" value="${extensions.join(', ')}" pattern="^[a-zA-Z0-9,\\s\\.]*$" maxlength="200">
                    <span class="form-validation-icon"><i class="bi"></i></span>
                </div>
            </td>
            <td><button class="btn btn-danger btn-sm" type="button" onclick="deleteRow(this)">Delete</button></td>
        `;
        tbody.appendChild(row);
        rowNum++;
    }
    
    // Initialize form validation on all inputs
    initializeFormValidation(tbody);
    
    // Initialize table sorting
    const table = tbody.closest('table');
    if (table) {
        initializeTableSorting(table.closest('.dashboard-module') || document);
    }
}

async function initializeCustomRoutes() {
    try {
        const response = await fetch('/api/organizer/config', {
            credentials: 'include',
            headers: getAuthHeaders()
        });
        
        if (response.ok) {
            const config = await response.json();
            
            // Load file categories
            if (config.routes && Object.keys(config.routes).length > 0) {
                loadFileCategories(config.routes);
            }
            
            // Load custom routes
            if (config.custom_routes && Object.keys(config.custom_routes).length > 0) {
                loadCustomRoutes(config.custom_routes);
            }
            
            // Load tag routes
            if (config.tag_routes && Object.keys(config.tag_routes).length > 0) {
                loadTagRoutes(config.tag_routes);
            }
        }
    } catch (error) {
        console.log('Could not load configuration:', error);
    }
}

// Load tag routes from config on page load
function loadTagRoutes(tagRoutes) {
    const tbody = document.getElementById('tag-routes-tbody');
    if (!tbody) return; // Not on dashboard page
    
    tbody.innerHTML = ''; // Clear existing rows
    
    if (tagRoutes && Object.keys(tagRoutes).length > 0) {
        let index = 1;
        for (const [tag, path] of Object.entries(tagRoutes)) {
            const row = document.createElement('tr');
            row.innerHTML = `
                <td>
                    <div class="form-validation-wrapper">
                        <input class="form-control form-control-sm" type="text" name="tag_${index}" value="${tag}" required pattern="^[a-zA-Z0-9_\\-\\s]+$" maxlength="50">
                        <span class="form-validation-icon"><i class="bi"></i></span>
                    </div>
                </td>
                <td>
                    <div class="form-validation-wrapper">
                        <input class="form-control form-control-sm" type="text" name="tagpath_${index}" value="${path}" required maxlength="255">
                        <span class="form-validation-icon"><i class="bi"></i></span>
                    </div>
                </td>
                <td><button class="btn btn-danger btn-sm" type="button" onclick="deleteRow(this)">Delete</button></td>
            `;
            tbody.appendChild(row);
            index++;
        }
    }
    
    // Initialize form validation on all inputs
    initializeFormValidation(tbody);
    
    // Initialize table sorting
    const table = tbody.closest('table');
    if (table) {
        initializeTableSorting(table.closest('.dashboard-module') || document);
    }
}

// Log streaming
function streamLog(which) {
    const logElement = document.getElementById(`${which}-log`);
    // Only stream if the log element exists (config page only)
    if (!logElement) {
        console.log(`Log element ${which}-log not found, skipping stream`);
        return;
    }
    
    const eventSource = new EventSource(`/stream/${which}`);
    eventSource.onmessage = function(event) {
        if (event.data && logElement) {
            logElement.textContent += event.data + '\n';
            logElement.scrollTop = logElement.scrollHeight;
        }
    };
    eventSource.onerror = function() {
        eventSource.close();
        // Only retry if element still exists
        if (document.getElementById(`${which}-log`)) {
            setTimeout(() => streamLog(which), 5000);
        }
    };
}

// Clear log
async function clearLog(which) {
    try {
        const response = await fetch(`/clear_log/${which}`, {
            method: 'POST',
            credentials: 'include',
            headers: getAuthHeaders()
        });
        if (response.ok) {
            const logElement = document.getElementById(`${which}-log`);
            logElement.textContent = '';
            showNotification(`${which.toUpperCase()} log cleared`, 'success');
        } else {
            showNotification(`Failed to clear ${which} log`, 'danger');
        }
    } catch (error) {
        showNotification(`Error: ${error.message}`, 'danger');
    }
}

// Show notification in fixed container
function showNotification(message, type) {
    const alertDiv = document.createElement('div');
    alertDiv.className = `alert alert-${type} alert-dismissible fade show`;
    alertDiv.innerHTML = `
        ${message}
        <button type="button" class="btn-close" data-bs-dismiss="alert"></button>
    `;
    
    const container = document.getElementById('notification-container');
    if (container) {
        container.appendChild(alertDiv);
    } else {
        // Fallback for pages without notification container
        const mainContainer = document.querySelector('.container');
        mainContainer.insertBefore(alertDiv, mainContainer.firstChild);
    }
    
    setTimeout(() => {
        alertDiv.remove();
    }, 5000);

    // Persist to Notification Center - ONLY for errors and warnings, skip success/info
    if (type === 'danger' || type === 'warning') {
        try {
            fetch('/api/notifications', {
                method: 'POST',
                credentials: 'include',
                headers: { 
                    ...getAuthHeaders(),
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({ message, type })
            }).then(() => {
                // Refresh notification badge/count
                if (typeof loadNotificationCenter === 'function') {
                    loadNotificationCenter();
                }
            }).catch(() => {});
        } catch(e) {}
    }
}

// Recent Files Functions
async function refreshRecentFiles() {
    const btn = document.getElementById('btn-recent-refresh');
    const tbody = document.getElementById('recent-files-tbody');
    const originalHtml = btn ? btn.innerHTML : '';
    
    try {
        if (btn) {
            btn.disabled = true;
            btn.innerHTML = '<span class="spinner-border spinner-border-sm me-1"></span>Loading...';
        }
        
        // Ensure VT config is loaded before displaying files
        await loadOrganizerConfig();
        
        const response = await fetch('/api/recent_files', {
            credentials: 'include',
            headers: getAuthHeaders()
        });
        
        if (!response.ok) {
            throw new Error('Failed to fetch recent files');
        }
        
        const files = await response.json();
        displayRecentFiles(files);
    } catch (error) {
        console.error('Error fetching recent files:', error);
        if (tbody) {
            tbody.innerHTML = '<tr><td colspan="5" class="text-center text-danger">Error loading recent files</td></tr>';
        }
        showNotification('Failed to refresh recent files: ' + error.message, 'danger');
    } finally {
        if (btn) {
            btn.disabled = false;
            btn.innerHTML = originalHtml || '<i class="bi bi-arrow-clockwise"></i> Refresh';
        }
    }
}

function displayRecentFiles(files) {
    const tbody = document.getElementById('recent-files-tbody');
    if (!tbody) return; // not present on this page
    
    if (!files || files.length === 0) {
        tbody.innerHTML = '<tr><td colspan="5" class="text-center text-muted">No recent file movements</td></tr>';
        return;
    }
    
    tbody.innerHTML = files.map(file => {
        const timestamp = new Date(file.timestamp);
        const timeStr = timestamp.toLocaleString();
        const categoryBadge = getCategoryBadge(file.category);
        
        const fileIndex = files.indexOf(file);
        return `
            <tr>
                <td><small>${timeStr}</small></td>
                <td>
                    <small><strong>${escapeHtml(file.filename)}</strong></small>
                    <br><small class="text-muted">${escapeHtml(file.destination_path)}</small>
                </td>
                <td>${categoryBadge}</td>
                <td>
                    <div class="d-flex flex-wrap gap-1" style="min-width: fit-content;">
                        <button class="btn btn-sm btn-primary" onclick='openFile(${JSON.stringify(file.destination_path)}, "open")' title="Open file">
                            <i class="bi bi-folder2-open"></i> Open
                        </button>
                        <button class="btn btn-sm btn-secondary" onclick='openFile(${JSON.stringify(file.destination_path)}, "reveal")' title="Show in folder">
                            <i class="bi bi-folder"></i> Show
                        </button>
                        ${(window.__organizerFeatures?.virustotal_enabled && window.__vtApiKey) ? `<button class="btn btn-sm btn-info" onclick='scanVirusTotal(${JSON.stringify(file.destination_path)}, ${JSON.stringify(file.filename)})' title="Scan with VirusTotal"><i class="bi bi-shield-check"></i> VT</button>` : ''}
                        <button class="btn btn-sm btn-danger" onclick='removeRecentFile(${fileIndex})' title="Remove from recent">
                            <i class="bi bi-x-lg"></i>
                        </button>
                    </div>
                </td>
            </tr>
        `;
    }).join('');
}

function getCategoryBadge(category) {
    const categories = {
        'Images': { class: 'bg-success', icon: 'bi-image' },
        'Videos': { class: 'bg-primary', icon: 'bi-camera-video' },
        'Music': { class: 'bg-info', icon: 'bi-music-note-beamed' },
        'Documents': { class: 'bg-warning text-dark', icon: 'bi-file-text' },
        'Archives': { class: 'bg-secondary', icon: 'bi-file-zip' },
        'Executables': { class: 'bg-danger', icon: 'bi-file-binary' },
        'Scripts': { class: 'bg-purple text-light', icon: 'bi-code-slash' },
        'Fonts': { class: 'bg-indigo text-light', icon: 'bi-fonts' },
        'Shortcuts': { class: 'bg-cyan text-dark', icon: 'bi-link-45deg' },
        'Logs': { class: 'bg-dark text-light', icon: 'bi-file-earmark-text' },
        'Other': { class: 'bg-secondary', icon: 'bi-question-circle' }
    };
    const categoryData = categories[category] || { class: 'bg-secondary', icon: 'bi-file' };
    return `<span class="badge ${categoryData.class}"><i class="bi ${categoryData.icon}"></i> ${escapeHtml(category)}</span>`;
}

async function openFile(filePath, action = 'open') {
    try {
        const response = await fetch('/api/open_file', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                ...getAuthHeaders()
            },
            credentials: 'include',
            body: JSON.stringify({
                file_path: filePath,
                action: action
            })
        });
        
        const data = await response.json();
        
        if (response.ok) {
            showNotification(data.message || `File ${action === 'reveal' ? 'revealed' : 'opened'}`, 'success');
        } else {
            showNotification(data.error || 'Failed to open file', 'danger');
        }
    } catch (error) {
        showNotification(`Error: ${error.message}`, 'danger');
    }
}

function escapeHtml(text) {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
}

async function removeRecentFile(index) {
    if (!confirm('Remove this file from recent files list?')) {
        return;
    }
    
    try {
        const response = await fetch(`/api/recent_files/${index}`, {
            method: 'DELETE',
            credentials: 'include',
            headers: getAuthHeaders()
        });
        
        if (response.ok) {
            showNotification('File removed from recent files', 'success');
            refreshRecentFiles();
        } else {
            const data = await response.json();
            showNotification(data.error || 'Failed to remove file', 'danger');
        }
    } catch (error) {
        showNotification(`Error: ${error.message}`, 'danger');
    }
}

// Developer Mode Management
async function loadDeveloperMode() {
    try {
        const response = await fetch('/api/organizer/config', {
            credentials: 'include',
            cache: 'no-store',
            headers: getAuthHeaders()
        });
        
        if (response.ok) {
            const config = await response.json();
            const features = config.features || {};
            const developerMode = features.developer_mode === true;
            
            // Apply developer mode class to body
            if (developerMode) {
                document.body.classList.add('developer-mode');
            } else {
                document.body.classList.remove('developer-mode');
            }
        }
    } catch (error) {
        console.log('Could not load developer mode setting:', error);
    }
}

// Sidebar Updates
let sidebarStatsChart = null;

async function updateSidebarMetrics() {
    // Only run if sidebar elements exist (not on config page)
    if (!document.getElementById('sidebar-ram-bar')) return;
    
    try {
        const response = await fetch('/metrics', {
            credentials: 'include',
            headers: getAuthHeaders()
        });
        
        if (response.ok) {
            const data = await response.json();
            
            // Update RAM
            const ramBar = document.getElementById('sidebar-ram-bar');
            const ramText = document.getElementById('sidebar-ram-text');
            if (ramBar && data.ram_percent !== undefined) {
                ramBar.style.width = data.ram_percent + '%';
                ramBar.textContent = data.ram_percent + '%';
                ramBar.className = 'progress-bar ' + 
                    (data.ram_percent < 50 ? 'bg-success' : 
                     data.ram_percent < 80 ? 'bg-warning' : 'bg-danger');
            }
            if (ramText && data.total_memory_mb && data.total_memory_gb) {
                ramText.textContent = `${data.total_memory_mb}/${data.total_memory_gb}GB`;
            }
            
            // Update CPU
            const cpuBar = document.getElementById('sidebar-cpu-bar');
            const cpuText = document.getElementById('sidebar-cpu-text');
            if (cpuBar && data.total_cpu_percent !== undefined) {
                cpuBar.style.width = data.total_cpu_percent + '%';
                cpuBar.textContent = data.total_cpu_percent + '%';
                cpuBar.className = 'progress-bar ' + 
                    (data.total_cpu_percent < 50 ? 'bg-success' : 
                     data.total_cpu_percent < 80 ? 'bg-warning' : 'bg-danger');
            }
            if (cpuText && data.total_cpu_percent !== undefined) {
                cpuText.textContent = `System: ${data.total_cpu_percent}%`;
            }
            
            // Update task manager
            if (data.top_processes && data.top_processes.length > 0) {
                const tbody = document.getElementById('sidebar-tasks-body');
                if (tbody) {
                    tbody.innerHTML = data.top_processes.slice(0, 3).map(proc => `
                        <tr>
                            <td style="padding: 0.15rem 0.25rem;">${proc.name.substring(0, 15)}</td>
                            <td style="padding: 0.15rem 0.25rem;">${proc.cpu.toFixed(1)}</td>
                            <td style="padding: 0.15rem 0.25rem;">${proc.mem}M</td>
                        </tr>
                    `).join('');
                }
            }
        }
    } catch (error) {
        console.log('Could not update sidebar metrics:', error);
    }
}

async function updateSidebarStats() {
    // Only run if sidebar elements exist (not on config page)
    if (!document.getElementById('sidebar-stat-total')) return;
    
    try {
        const response = await fetch('/api/statistics/overview', {
            credentials: 'include',
            headers: getAuthHeaders()
        });
        
        if (response.ok) {
            const data = await response.json();
            
            const totalEl = document.getElementById('sidebar-stat-total');
            const todayEl = document.getElementById('sidebar-stat-today');
            
            if (totalEl) totalEl.textContent = data.total_files || 0;
            if (todayEl) todayEl.textContent = data.today_count || 0;
            
            // Update mini chart (ApexCharts)
            const chartContainer = document.getElementById('sidebar-stats-chart');
            if (chartContainer) {
                const categoryRes = await fetch('/api/statistics/by-category', {
                    credentials: 'include',
                    headers: getAuthHeaders()
                });
                
                if (categoryRes.ok) {
                    const categoryData = await categoryRes.json();
                    
                    if (sidebarStatsChart) {
                        sidebarStatsChart.destroy();
                    }
                    
                    sidebarStatsChart = new ApexCharts(chartContainer, {
                        chart: {
                            type: 'donut',
                            height: 150,
                            animations: { enabled: true, speed: 400 }
                        },
                        series: categoryData.data || categoryData.values || [],
                        labels: categoryData.labels || [],
                        colors: ['#FF6384', '#36A2EB', '#FFCE56', '#4BC0C0', '#9966FF', '#FF9F40', '#FF6384', '#C9CBCF'],
                        legend: { show: false },
                        dataLabels: { enabled: false },
                        plotOptions: {
                            pie: {
                                donut: {
                                    size: '70%',
                                    labels: { show: false }
                                }
                            }
                        },
                        tooltip: { enabled: true, y: { formatter: (val) => val + ' files' } }
                    });
                    sidebarStatsChart.render();
                }
            }
        }
    } catch (error) {
        console.log('Could not update sidebar stats:', error);
    }
}

function openStatsWindow() {
    const featuresEnabled = __organizerFeatures && __organizerFeatures.reports_enabled !== false;
    if (!featuresEnabled) {
        showNotification('Reports & Analytics are disabled in Features.', 'warning');
        return;
    }
    const w = Math.min(screen.width - 100, 1280);
    const h = Math.min(screen.height - 100, 900);
    const left = Math.max(0, (screen.width - w) / 2);
    const top = Math.max(0, (screen.height - h) / 2);
    window.open('/statistics/full', 'StatisticsFullView', `width=${w},height=${h},left=${left},top=${top},resizable=yes,scrollbars=yes`);
}

// Initialize on page load
// Lazy Loading for Duplicates Module
let duplicatesModuleLoaded = false;

function initLazyLoadDuplicates() {
    const duplicatesCard = document.getElementById('card-duplicates');
    if (!duplicatesCard) {
        console.warn('Duplicates card not found, skipping lazy load');
        return;
    }
    
    // Create intersection observer to detect when module becomes visible
    const observer = new IntersectionObserver((entries) => {
        entries.forEach(entry => {
            if (entry.isIntersecting && !duplicatesModuleLoaded) {
                console.log('Duplicates module now visible, loading...');
                duplicatesModuleLoaded = true;
                loadDuplicatesModule();
                observer.disconnect(); // Stop observing after loading once
            }
        });
    }, {
        root: null, // viewport
        rootMargin: '100px', // Start loading 100px before it enters viewport
        threshold: 0.01 // Trigger when even 1% is visible
    });
    
    observer.observe(duplicatesCard);
    
    // Also listen for manual refresh button click (in case module not yet loaded)
    const refreshBtn = document.getElementById('btn-duplicates-refresh');
    if (refreshBtn) {
        refreshBtn.addEventListener('click', function() {
            if (!duplicatesModuleLoaded) {
                loadDuplicatesModule();
            }
        });
    }
}

async function loadDuplicatesModule() {
    if (duplicatesModuleLoaded) return; // Already loaded or in progress
    duplicatesModuleLoaded = true;
    
    try {
        // Dynamically load the duplicates module script
        const script = document.createElement('script');
        script.src = `/static/js/duplicates-module.js?v={{ asset_version }}`;
        script.async = true;
        
        // Wait for script to load
        await new Promise((resolve, reject) => {
            script.onload = resolve;
            script.onerror = () => reject(new Error('Failed to load duplicates module'));
            document.head.appendChild(script);
        });
        
        // After module loads, initialize it
        if (typeof window.loadDuplicates === 'function') {
            console.log('✓ Duplicates module loaded successfully');
            window.loadDuplicates();
            window.loadWatchedFolders();
        } else {
            console.error('Duplicates module loaded but functions not available');
        }
    } catch (error) {
        console.error('Error loading duplicates module:', error);
        duplicatesModuleLoaded = false; // Allow retry
        showNotification('Failed to load duplicates module', 'danger');
    }
}

document.addEventListener('DOMContentLoaded', function() {
    loadCustomWidgets();
    initDragAndDrop(); // Initialize GridStack first
    loadDashboardLayout(); // Then load saved layout
    // loadHiddenModules() removed - Alpine.js handles state automatically
    initResizableTables();
    syncAuthButtons();
    initSidebarResizer();
    
    // Initialize notification center (only once on page load)
    loadNotificationCenter();
    // Clear any existing notification polling interval
    if (notificationPollingInterval) {
        clearInterval(notificationPollingInterval);
    }
    // Start notification polling every 30 seconds
    notificationPollingInterval = setInterval(loadNotificationCenter, 30000);
    
    // checkShowIntro() removed - Alpine.js manages intro modal visibility automatically
    
    // Load developer mode setting
    loadDeveloperMode();
    
    // Initialize sidebar updates (only if sidebar exists)
    if (document.getElementById('sidebar')) {
        updateSidebarMetrics();
        updateSidebarStats();
        
        // Update sidebar periodically
        setInterval(updateSidebarMetrics, 5000); // Every 5 seconds
        setInterval(updateSidebarStats, 30000); // Every 30 seconds
    }

    // Cookie-based auth persistence helpers
    function setCookie(name, value, days) {
        const d = new Date();
        d.setTime(d.getTime() + (days*24*60*60*1000));
        const expires = 'expires=' + d.toUTCString();
        const secure = location.protocol === 'https:' ? '; Secure' : '';
        document.cookie = name + '=' + encodeURIComponent(value) + '; ' + expires + '; Path=/' + '; SameSite=Lax' + secure;
    }
    function getCookie(name) {
        const decoded = decodeURIComponent(document.cookie || '');
        const ca = decoded.split(';');
        name = name + '=';
        for (let c of ca) {
            while (c.charAt(0) === ' ') c = c.substring(1);
            if (c.indexOf(name) === 0) return c.substring(name.length, c.length);
        }
        return null;
    }
    function deleteCookie(name) {
        const secure = location.protocol === 'https:' ? '; Secure' : '';
        document.cookie = name + '=; expires=Thu, 01 Jan 1970 00:00:00 GMT; Path=/; SameSite=Lax' + secure;
    }

    // Restore auth from sessionStorage or cookie if available
    try {
        let storedAuth = sessionStorage.getItem('authHeader');
        if (!storedAuth) {
            storedAuth = getCookie('authHeader');
        }
        if (storedAuth) {
            __authHeader = storedAuth;
            // Verify stored auth is still valid
            fetch('/auth_check', {
                credentials: 'include',
                headers: { 'Authorization': __authHeader }
            }).then(response => {
                if (response.ok) {
                    return response.json();
                } else {
                    __authHeader = null;
                    sessionStorage.removeItem('authHeader');
                    deleteCookie('authHeader');
                    throw new Error('Stored auth invalid');
                }
            }).then(data => {
                __rights = data.rights || {};
                __configVersion = data.config_version || 0;
                document.getElementById('login-btn').classList.add('d-none');
                document.getElementById('logout-btn').classList.remove('d-none');
                if (__rights.manage_config || __rights.modify_layout) {
                    document.getElementById('config-link').classList.remove('d-none');
                }
                applyRights();
                if (__rights.view_recent_files) refreshRecentFiles();
                if (__rights.view_metrics) {
                    updateServiceStatus();
                    streamLog('stdout');
                    streamLog('stderr');
                }
                // Initialize custom routes table if present
                initializeCustomRoutes();
            }).catch(err => {
                console.log('Auth restoration failed:', err);
            });
        }
    } catch (e) {
        console.warn('sessionStorage not available:', e);
    }
    
    // Initialize custom routes table on dashboard load
    initializeCustomRoutes();
    
    // Intercept config link clicks to use fetch with auth header
    const configLink = document.getElementById('config-link');
    if (configLink) {
        configLink.addEventListener('click', function(e) {
            e.preventDefault();
            if (!__authHeader) {
                showNotification('Please login first', 'warning');
                return;
            }
            // Navigate to config page
            window.location.href = '/config';
        });
    }
    
    fetchServiceName();
    // Fetch CSRF token
    fetchCSRFToken();
    // Start polling rights periodically
    setInterval(pollRights, __rightsPollIntervalMs);
    // Load dashboard data with feature gating
    if (__organizerFeatures.reports_enabled) {
        loadStatistics();
    } else {
        const el = document.getElementById('chart-category');
        if (el) {
            const parent = el.closest('.card-body');
            if (parent) parent.insertAdjacentHTML('afterbegin', '<div class="alert alert-warning alert-sm py-1 px-2"><small>Reports & Analytics are disabled in Features.</small></div>');
        }
    }
    
    // Lazy load duplicates module when visible
    if (__organizerFeatures.duplicates_enabled) {
        initLazyLoadDuplicates();
    } else {
        showNotification('Duplicate Detection is disabled in Features.', 'warning');
    }
});

// Statistics Charts

// Duplicate Files Management
// NOTE: These functions are now lazy-loaded from duplicates-module.js
// Keeping stub functions for backwards compatibility until module loads
async function loadDuplicates() {
    // This will be replaced when duplicates-module.js loads
    console.log('loadDuplicates stub called - waiting for module to load');
    if (!duplicatesModuleLoaded) {
        await loadDuplicatesModule();
    }
}

async function loadWatchedFolders() {
    // This will be replaced when duplicates-module.js loads
    console.log('loadWatchedFolders stub called - waiting for module to load');
}

function toggleGroupSelection() {
    console.log('toggleGroupSelection stub - module not loaded yet');
}

function keepNewest() {
    console.log('keepNewest stub - module not loaded yet');
}

function keepLargest() {
    console.log('keepLargest stub - module not loaded yet');
}

function deleteAllDuplicates() {
    console.log('deleteAllDuplicates stub - module not loaded yet');
}

function deleteSingleFile() {
    console.log('deleteSingleFile stub - module not loaded yet');
}

function deleteSelectedFiles() {
    console.log('deleteSelectedFiles stub - module not loaded yet');
}

function resolveDuplicates() {
    console.log('resolveDuplicates stub - module not loaded yet');
}

/* ORIGINAL DUPLICATES FUNCTIONS - NOW IN duplicates-module.js
   All duplicate-related functions have been moved to static/js/duplicates-module.js
   for lazy loading. This reduces initial page load by ~400 lines of JavaScript.
   The module is loaded when the duplicates card becomes visible or when the
   refresh button is clicked.
   
   Original functions moved:
   - loadDuplicates()
   - loadWatchedFolders()
   - toggleGroupSelection()
   - keepNewest()
   - keepLargest()
   - deleteAllDuplicates()
   - deleteSingleFile()
   - deleteSelectedFiles()
   - resolveDuplicates()
   
   COMMENTED OUT ORIGINAL CODE BELOW:
   
async function loadDuplicates_ORIGINAL() {
    const btn = document.getElementById('btn-duplicates-refresh');
    const originalHtml = btn ? btn.innerHTML : '';
    const container = document.getElementById('duplicates-container');
    const countBadge = document.getElementById('duplicates-count');
    const wastedBadge = document.getElementById('wasted-space');
    
    try {
        if (btn) {
            btn.disabled = true;
            btn.innerHTML = '<span class="spinner-border spinner-border-sm me-1"></span>Scanning...';
        }
        if (container) {
            container.innerHTML = `
                <div class="text-center text-muted py-4">
                    <div class="spinner-border text-primary mb-2"></div>
                    <p class="mb-0">Scanning for duplicates...</p>
                </div>`;
        }
        
        const res = await fetch('/api/duplicates', {
            credentials: 'include',
            headers: getAuthHeaders()
        });
        
        if (!res.ok) {
            let message = 'Failed to load duplicates';
            try {
                const err = await res.json();
                message = err.error || message;
            } catch (_) {}
            throw new Error(message);
        }
        
        const data = await res.json();
        window.duplicatesData = data;
        
        if (countBadge) {
            countBadge.textContent = `${data.total_duplicates} duplicate group${data.total_duplicates === 1 ? '' : 's'}`;
        }
        if (wastedBadge) {
            wastedBadge.textContent = `${data.wasted_space_human} wasted`;
        }
        if (!container) return;
        
        if (!data.duplicates || data.duplicates.length === 0) {
            container.innerHTML = `
                <div class="text-center text-success py-4">
                    <i class="bi bi-check-circle fs-1"></i>
                    <p class="mb-0">No duplicate files found!</p>
                </div>`;
            return;
        }
        
        const cards = data.duplicates.map((group, index) => {
            const files = Array.isArray(group.files) ? group.files : [];
            const fileCount = group.count || files.length;
            const totalSizeLabel = escapeHtml(group.total_size_human || '');
            const hashPreviewRaw = (group.hash || '').substring(0, 12);
            const hashPreview = hashPreviewRaw ? escapeHtml(hashPreviewRaw) : '';
            const hashDisplay = hashPreview ? `${hashPreview}...` : 'n/a';
            const fileRows = files.map((file, fileIndex) => {
                const safePath = escapeHtml(file.path || '');
                const deletePath = JSON.stringify(file.path || '');
                const sizeLabel = escapeHtml(file.size_human || '');
                const modifiedLabel = escapeHtml(file.modified_human || '');
                return `
                    <tr>
                        <td style="width: 30px;"><input type="checkbox" data-group="${index}" data-file="${fileIndex}" data-path="${safePath}"></td>
                        <td style="max-width: 250px; word-wrap: break-word; word-break: break-word;"><i class="bi bi-file-earmark"></i> ${escapeHtml(file.name || 'Unknown')}</td>
                        <td style="min-width: 70px; white-space: nowrap;">${sizeLabel || '—'}</td>
                        <td style="min-width: 130px; white-space: nowrap;"><small>${modifiedLabel || '—'}</small></td>
                        <td style="word-wrap: break-word; word-break: break-word;"><small class="text-muted">${safePath}</small></td>
                        <td style="min-width: 80px; text-align: center;">
                            <button class="btn btn-sm btn-danger" onclick="deleteSingleFile(${deletePath})" title="Delete this file">
                                <i class="bi bi-trash"></i>
                            </button>
                        </td>
                    </tr>
                `;
            }).join('');
            
            return `
                <div class="card mb-3">
                    <div class="card-header" style="background-color: var(--bg-secondary);">
                        <div class="d-flex flex-column flex-lg-row justify-content-between align-items-lg-center gap-2">
                            <div>
                                <strong>${fileCount} files</strong> - ${totalSizeLabel || 'Unknown size'}
                                <small class="text-muted">(Hash: ${hashDisplay})</small>
                            </div>
                            <div class="d-flex flex-wrap gap-2">
                                <button class="btn btn-sm btn-primary" onclick="keepNewest(${index})" title="Keep newest file, delete older duplicates">
                                    <i class="bi bi-clock"></i> Keep Newest
                                </button>
                                <button class="btn btn-sm btn-success" onclick="keepLargest(${index})" title="Keep largest file, delete smaller duplicates">
                                    <i class="bi bi-file-earmark"></i> Keep Largest
                                </button>
                                <button class="btn btn-sm btn-danger" onclick="deleteAllDuplicates(${index})" title="Delete all files in this group">
                                    <i class="bi bi-trash"></i> Delete All
                                </button>
                            </div>
                        </div>
                    </div>
                    <div class="card-body p-0">
                        <div class="table-responsive">
                            <table class="table table-sm table-hover mb-0" style="table-layout: auto; width: 100%;">
                                <thead>
                                    <tr>
                                        <th style="width: 30px;"><input type="checkbox" onchange="toggleGroupSelection(${index}, this.checked)" title="Select all files in group"></th>
                                        <th style="width: 25%;">Name</th>
                                        <th style="width: 8%; min-width: 70px;">Size</th>
                                        <th style="width: 15%; min-width: 130px;">Modified</th>
                                        <th style="width: auto;">Path</th>
                                        <th style="width: 80px; min-width: 80px; text-align: center;">Actions</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    ${fileRows || '<tr><td colspan="6" class="text-center text-muted">No file details available</td></tr>'}
                                </tbody>
                            </table>
                        </div>
                    </div>
                </div>
            `;
        }).join('');
        
        container.innerHTML = cards;
    } catch (error) {
        console.error('Error loading duplicates:', error);
        if (container) {
            container.innerHTML = `
                <div class="alert alert-danger mb-0">
                    <i class="bi bi-exclamation-triangle"></i> ${escapeHtml(error.message || 'Failed to load duplicates')}
                </div>`;
        }
        showNotification('Failed to load duplicates: ' + error.message, 'danger');
    } finally {
        if (btn) {
            btn.disabled = false;
            btn.innerHTML = originalHtml || '<i class="bi bi-arrow-clockwise"></i> Refresh';
        }
    }
}

async function loadWatchedFolders() {
    try {
        const res = await fetch('/api/watch_folders', {
            credentials: 'include',
            headers: { 'Authorization': __authHeader }
        });
        if (!res.ok) return;
        const data = await res.json();
        const folders = Array.isArray(data.folders) ? data.folders : [];
        const badge = document.getElementById('watched-folders-badge');
        const list = document.getElementById('watched-folders-list');
        const ul = document.getElementById('watched-folders-ul');
        if (badge) badge.textContent = `watching ${folders.length}`;
        if (ul) {
            ul.innerHTML = folders.map(f => `<li><small class="text-muted">${f}</small></li>`).join('');
        }
        if (list) list.style.display = folders.length ? 'block' : 'none';
    } catch (e) {
        console.error('Failed to load watched folders', e);
    }
}

function toggleGroupSelection(groupIndex, checked) {
    document.querySelectorAll(`input[data-group="${groupIndex}"]`).forEach(checkbox => {
        checkbox.checked = checked;
    });
}

async function keepNewest(groupIndex) {
    if (!window.duplicatesData) return;
    
    const group = window.duplicatesData.duplicates[groupIndex];
    if (!group || group.files.length < 2) return;
    
    // Keep first file (newest by sort), delete rest
    const filesToDelete = group.files.slice(1).map(f => f.path);
    
    if (!confirm(`Delete ${filesToDelete.length} older duplicate(s) and keep the newest?`)) {
        return;
    }
    
    await resolveDuplicates(filesToDelete);
}

async function keepLargest(groupIndex) {
    if (!window.duplicatesData) return;
    
    const group = window.duplicatesData.duplicates[groupIndex];
    if (!group || group.files.length < 2) return;
    
    // Find largest file
    let largest = group.files[0];
    group.files.forEach(f => {
        if (f.size > largest.size) largest = f;
    });
    
    // Delete all except largest
    const filesToDelete = group.files.filter(f => f.path !== largest.path).map(f => f.path);
    
    if (!confirm(`Delete ${filesToDelete.length} duplicate(s) and keep the largest (${largest.size_human})?`)) {
        return;
    }
    
    await resolveDuplicates(filesToDelete);
}

async function deleteAllDuplicates(groupIndex) {
    if (!window.duplicatesData) return;
    
    const group = window.duplicatesData.duplicates[groupIndex];
    if (!group) return;
    
    const filesToDelete = group.files.map(f => f.path);
    
    if (!confirm(`Delete ALL ${filesToDelete.length} files in this duplicate group? This cannot be undone!`)) {
        return;
    }
    
    await resolveDuplicates(filesToDelete);
}

async function deleteSingleFile(filePath) {
    if (!confirm(`Delete this file?\n${filePath}\n\nThis cannot be undone!`)) {
        return;
    }
    
    await resolveDuplicates([filePath]);
}

async function deleteSelectedFiles() {
    const selected = Array.from(document.querySelectorAll('input[data-path]:checked')).map(cb => cb.dataset.path);
    
    if (selected.length === 0) {
        showToast('No files selected', 'warning');
        return;
    }
    
    if (!confirm(`Delete ${selected.length} selected file(s)? This cannot be undone!`)) {
        return;
    }
    
    await resolveDuplicates(selected);
}

async function resolveDuplicates(filePaths) {
    try {
        const res = await fetch('/api/duplicates/resolve', {
            method: 'POST',
            credentials: 'include',
            headers: {
                'Content-Type': 'application/json',
                ...getAuthHeaders()
            },
            body: JSON.stringify({
                action: 'delete',
                files: filePaths
            })
        });
        
        if (res.ok) {
            const result = await res.json();
            showToast(result.message, 'success');
            
            // Reload duplicates
            loadDuplicates();
        } else {
            const error = await res.json();
            showToast('Failed to delete files: ' + (error.error || 'Unknown error'), 'error');
        }
    } catch (error) {
        console.error('Error resolving duplicates:', error);
        showNotification('Error: ' + error.message, 'danger');
    }
}
END OF COMMENTED OUT DUPLICATES CODE */

async function scanVirusTotal(filePath, fileName) {
    try {
        const url = '/api/recent_files/virustotal';
        console.log('[VT] Scanning file:', filePath);
        console.log('[VT] Calling URL:', url);
        console.log('[VT] Headers:', getAuthHeaders());
        const res = await fetch(url, {
            method: 'POST',
            credentials: 'include',
            headers: {
                'Content-Type': 'application/json',
                ...getAuthHeaders()
            },
            body: JSON.stringify({ path: filePath })
        });
        console.log('[VT] Response status:', res.status);
        console.log('[VT] Response URL:', res.url);
        
        const data = await res.json().catch(() => ({}));
        
        // Check for file not found in VT database
        if (res.status === 404 && data.error && typeof data.error === 'string' && data.error.includes('NotFoundError')) {
            // File exists locally but not in VT database - offer upload link
            const uploadUrl = 'https://www.virustotal.com/gui/home/upload';
            showNotification(`File not found in VirusTotal database. <a href="${uploadUrl}" target="_blank" class="text-white text-decoration-underline">Click here to upload and scan it</a>.`, 'info', 8000);
            return;
        }
        
        // Check for local file not found
        if (res.status === 404 && data.error === 'File not found') {
            showNotification('File not found on disk. It may have been moved or deleted.', 'warning');
            return;
        }
        
        if (res.ok) {
            const attrs = data.data && data.data.attributes;
            const stats = attrs && attrs.last_analysis_stats;
            // Notification summary
            if (stats) {
                showNotification(`VT: ${fileName} clean:${stats.undetected} malicious:${stats.malicious} suspicious:${stats.suspicious||0}`, 'info');
            } else {
                showNotification('VirusTotal scan requested. Check VT for detailed report.', 'info');
            }
            // Populate modal details
            try {
                const engines = attrs && attrs.last_analysis_results ? attrs.last_analysis_results : {};
                const rows = Object.keys(engines).map(name => {
                    const r = engines[name] || {};
                    const c = r.category || 'unknown';
                    const verdict = r.result || '';
                    const badge = c === 'malicious' ? 'badge bg-danger' : c === 'suspicious' ? 'badge bg-warning text-dark' : 'badge bg-success';
                    return `<tr><td><small>${name}</small></td><td><span class="${badge}">${c}</span></td><td><small>${verdict}</small></td></tr>`;
                }).join('');
                const sha256 = attrs && attrs.sha256 ? attrs.sha256 : '';
                const link = sha256 ? `https://www.virustotal.com/gui/file/${sha256}` : '#';
                const bodyHtml = `
                    <div class="mb-2"><strong>${escapeHtml(fileName)}</strong></div>
                    ${stats ? `<div class="mb-3">Malicious: ${stats.malicious} • Suspicious: ${stats.suspicious||0} • Undetected: ${stats.undetected} • Harmless: ${stats.harmless||0}</div>` : ''}
                    <div class="table-responsive">
                        <table class="table table-sm">
                            <thead><tr><th>Engine</th><th>Status</th><th>Verdict</th></tr></thead>
                            <tbody>${rows || '<tr><td colspan="3" class="text-muted">No engine results</td></tr>'}</tbody>
                        </table>
                    </div>`;
                const modalBody = document.getElementById('vtModalBody');
                const modalLink = document.getElementById('vtReportLink');
                if (modalBody) modalBody.innerHTML = bodyHtml;
                if (modalLink) modalLink.href = link;
                // Show modal
                const modalEl = document.getElementById('vtModal');
                if (modalEl && typeof bootstrap !== 'undefined') {
                    const modal = bootstrap.Modal.getOrCreateInstance(modalEl);
                    modal.show();
                }
            } catch (e) {
                console.warn('Failed to render VT modal:', e);
            }
        } else {
            // Handle other errors
            let errorMsg = 'VirusTotal scan failed: ';
            if (res.status === 400 && data.error && data.error.includes('API key')) {
                errorMsg += 'API key not configured or invalid.';
            } else if (res.status === 403) {
                errorMsg += 'Access forbidden. Check API key permissions.';
            } else if (res.status === 429) {
                errorMsg += 'Rate limit exceeded. Please wait and try again.';
            } else {
                errorMsg += (data.error || `HTTP ${res.status}`);
            }
            showNotification(errorMsg, 'danger');
        }
    } catch (e) {
        showNotification('VirusTotal request failed: ' + e.message, 'danger');
    }
}
// Statistics Charts - MIGRATED TO APEXCHARTS
let chartCategory, chartExtensions, chartTimeline, chartHourly;

// Display drill-down details for a category
function showCategoryDrillDown(category, drillData) {
    // Create modal or toast showing the drill-down details
    const message = `
        <div class="p-3">
            <h6 class="mb-3">${category} Details</h6>
            <small class="d-block mb-2"><b>Total Files:</b> ${drillData.total || 0}</small>
            <small class="d-block mb-2"><b>Total Size:</b> ${formatBytes(drillData.total_size || 0)}</small>
            ${drillData.top_extensions ? `<small class="d-block mb-2"><b>Top Extensions:</b> ${drillData.top_extensions.slice(0, 3).join(', ')}</small>` : ''}
            <small class="d-block text-muted mt-2">Files in this category</small>
        </div>
    `;
    
    if (typeof showNotification === 'function') {
        // Show as notification
        showNotification(`${category}: ${drillData.total || 0} files (${formatBytes(drillData.total_size || 0)})`, 'info');
    }
}

// Helper function to format bytes to human readable
function formatBytes(bytes) {
    if (bytes === 0) return '0 B';
    const k = 1024;
    const sizes = ['B', 'KB', 'MB', 'GB', 'TB'];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    return Math.round((bytes / Math.pow(k, i)) * 100) / 100 + ' ' + sizes[i];
}

async function loadStatistics() {
    try {
        // Load overview stats
        const overviewRes = await fetch('/api/statistics/overview', {
            credentials: 'include',
            headers: { 'Authorization': __authHeader }
        });
        
        if (overviewRes.ok) {
            const overview = await overviewRes.json();
            const setTextIfExists = (id, value) => {
                const el = document.getElementById(id);
                if (el) el.textContent = value;
            };
            setTextIfExists('stat-total-files', overview.total_files || 0);
            setTextIfExists('stat-today', overview.today_count || 0);
            setTextIfExists('stat-week', overview.week_count || 0);
            setTextIfExists('stat-month', overview.month_count || 0);
            setTextIfExists('stat-categories', overview.total_categories || 0);
            setTextIfExists('stat-avg-day', overview.avg_per_day || 0);
        }
        
        // Load category chart (ApexCharts Donut with drill-down interactivity)
        const categoryRes = await fetch('/api/statistics/by-category', {
            credentials: 'include',
            headers: { 'Authorization': __authHeader }
        });
        
        if (categoryRes.ok) {
            const categoryData = await categoryRes.json();
            const container = document.getElementById('chart-category');
            if (container) {
                if (chartCategory) chartCategory.destroy();
                chartCategory = new ApexCharts(container, {
                    chart: {
                        type: 'donut',
                        height: 300,
                        animations: { enabled: true, easing: 'easeinout', speed: 800 },
                        events: {
                            click: async (event, chartContext, { seriesIndex }) => {
                                // Drill-down on segment click
                                const category = categoryData.labels?.[seriesIndex];
                                if (category) {
                                    try {
                                        const drillRes = await fetch(`/api/statistics/by-category-detail/${encodeURIComponent(category)}`, {
                                            credentials: 'include',
                                            headers: { 'Authorization': __authHeader }
                                        });
                                        if (drillRes.ok) {
                                            const drillData = await drillRes.json();
                                            showCategoryDrillDown(category, drillData);
                                        }
                                    } catch (e) {
                                        console.log('Could not drill down:', e);
                                    }
                                }
                            }
                        }
                    },
                    series: categoryData.data || [],
                    labels: categoryData.labels || [],
                    colors: ['#0d6efd', '#6610f2', '#6f42c1', '#d63384', '#dc3545', '#fd7e14', '#ffc107', '#198754', '#20c997', '#0dcaf0'],
                    legend: { position: 'right' },
                    dataLabels: { enabled: true, formatter: (val) => Math.round(val) + '%' },
                    plotOptions: {
                        pie: {
                            donut: {
                                size: '65%',
                                labels: {
                                    show: true,
                                    total: {
                                        show: true,
                                        label: 'Total Files',
                                        formatter: () => (categoryData.data || []).reduce((a,b) => a+b, 0)
                                    }
                                }
                            }
                        }
                    },
                    tooltip: { 
                        y: { formatter: (val) => val + ' files' },
                        custom: () => '<span style="font-size: 0.8rem;">Click to drill down</span>'
                    },
                    states: {
                        hover: { filter: { type: 'none', value: 0 } },
                        active: { filter: { type: 'none', value: 0 } }
                    }
                });
                chartCategory.render();
            }
        }
        
        // Load extensions chart (ApexCharts Bar)
        const extRes = await fetch('/api/statistics/by-extension', {
            credentials: 'include',
            headers: { 'Authorization': __authHeader }
        });
        
        if (extRes.ok) {
            const extData = await extRes.json();
            const container = document.getElementById('chart-extensions');
            if (container) {
                if (chartExtensions) chartExtensions.destroy();
                chartExtensions = new ApexCharts(container, {
                    chart: {
                        type: 'bar',
                        height: 300,
                        animations: { enabled: true, easing: 'easeinout', speed: 800 },
                        toolbar: { show: true, tools: { download: true, zoom: false } }
                    },
                    series: [{ name: 'Files', data: extData.data || [] }],
                    xaxis: { categories: extData.labels || [], labels: { rotate: -45, rotateAlways: true } },
                    yaxis: { title: { text: 'Number of Files' }, labels: { formatter: (val) => Math.round(val) } },
                    colors: ['#0d6efd'],
                    plotOptions: { bar: { borderRadius: 4, dataLabels: { position: 'top' } } },
                    dataLabels: { enabled: true, offsetY: -20, style: { colors: ['#333'] } },
                    tooltip: { y: { formatter: (val) => val + ' files' } }
                });
                chartExtensions.render();
            }
        }
        
        // Load timeline chart (ApexCharts Area)
        const timelineRes = await fetch('/api/statistics/timeline', {
            credentials: 'include',
            headers: { 'Authorization': __authHeader }
        });
        
        if (timelineRes.ok) {
            const timelineData = await timelineRes.json();
            const container = document.getElementById('chart-timeline');
            if (container) {
                if (chartTimeline) chartTimeline.destroy();
                chartTimeline = new ApexCharts(container, {
                    chart: {
                        type: 'area',
                        height: 250,
                        animations: { enabled: true, easing: 'easeinout', speed: 800 },
                        toolbar: { show: true, tools: { download: true, zoom: true, pan: true } },
                        zoom: { enabled: true }
                    },
                    series: [{ name: 'Files Organized', data: timelineData.data || [] }],
                    xaxis: { categories: timelineData.labels || [], labels: { rotate: -45, rotateAlways: true } },
                    yaxis: { title: { text: 'Files' }, labels: { formatter: (val) => Math.round(val) } },
                    colors: ['#198754'],
                    fill: { type: 'gradient', gradient: { shadeIntensity: 1, opacityFrom: 0.7, opacityTo: 0.3 } },
                    stroke: { curve: 'smooth', width: 2 },
                    dataLabels: { enabled: false },
                    tooltip: { y: { formatter: (val) => val + ' files' } }
                });
                chartTimeline.render();
            }
        }
        
        // Load hourly activity chart (ApexCharts Column)
        const hourlyRes = await fetch('/api/statistics/hourly-activity', {
            credentials: 'include',
            headers: { 'Authorization': __authHeader }
        });
        
        if (hourlyRes.ok) {
            const hourlyData = await hourlyRes.json();
            const container = document.getElementById('chart-hourly');
            if (container) {
                if (chartHourly) chartHourly.destroy();
                chartHourly = new ApexCharts(container, {
                    chart: {
                        type: 'bar',
                        height: 250,
                        animations: { enabled: true, easing: 'easeinout', speed: 800 },
                        toolbar: { show: false }
                    },
                    series: [{ name: 'Files', data: hourlyData.data || [] }],
                    xaxis: { categories: hourlyData.labels || [], title: { text: 'Hour of Day' } },
                    yaxis: { title: { text: 'Files' }, labels: { formatter: (val) => Math.round(val) } },
                    colors: ['#0dcaf0'],
                    plotOptions: { bar: { borderRadius: 4, columnWidth: '80%' } },
                    dataLabels: { enabled: false },
                    tooltip: { y: { formatter: (val) => val + ' files' } }
                });
                chartHourly.render();
            }
        }
        
    } catch (err) {
        console.error('Failed to load statistics:', err);
    }
}

// Notification Center Functions
let notificationCenterOpen = false;
let notificationPollingInterval = null;

async function loadNotificationCenter() {
    try {
        const response = await fetch('/api/notifications', {
            credentials: 'include',
            headers: { 'Authorization': __authHeader }
        });
        
        if (response.ok) {
            const data = await response.json();
            updateNotificationBadge(data.unread);
            renderNotifications(data.notifications);
        }
    } catch (err) {
        console.error('Failed to load notifications:', err);
    }
}

function updateNotificationBadge(count) {
    // Alpine.js handles badge display reactively via x-show and x-text
    // Just update the Alpine data property
    const bellContainer = document.querySelector('.notification-bell');
    if (bellContainer && window.Alpine) {
        const alpineData = Alpine.$data(bellContainer);
        if (alpineData) alpineData.unreadCount = count;
    }
}

function renderNotifications(notifications) {
    const body = document.getElementById('notification-body');
    if (!body) return;
    
    if (notifications.length === 0) {
        body.innerHTML = `
            <div class="notification-empty">
                <i class="bi bi-bell-slash"></i>
                <p>No notifications</p>
            </div>
        `;
        return;
    }
    
    body.innerHTML = notifications.map(notif => {
        const unreadClass = notif.read ? '' : 'unread';
        const typeIcon = getNotificationIcon(notif.type);
        const time = formatNotificationTime(notif.timestamp);
        
        return `
            <div class="notification-item ${unreadClass}" onclick="markNotificationRead('${notif.id}')">
                <div class="notification-message">
                    <i class="bi ${typeIcon}"></i> ${notif.message}
                </div>
                <div class="notification-time">${time}</div>
                <i class="bi bi-x-circle notification-delete" onclick="event.stopPropagation(); deleteNotification('${notif.id}')"></i>
            </div>
        `;
    }).join('');
}

function getNotificationIcon(type) {
    const icons = {
        'success': 'bi-check-circle-fill text-success',
        'danger': 'bi-exclamation-triangle-fill text-danger',
        'warning': 'bi-exclamation-circle-fill text-warning',
        'info': 'bi-info-circle-fill text-info'
    };
    return icons[type] || icons.info;
}

function formatNotificationTime(timestamp) {
    try {
        const date = new Date(timestamp);
        const now = new Date();
        const diffMs = now - date;
        const diffMins = Math.floor(diffMs / 60000);
        const diffHours = Math.floor(diffMs / 3600000);
        const diffDays = Math.floor(diffMs / 86400000);
        
        if (diffMins < 1) return 'Just now';
        if (diffMins < 60) return `${diffMins}m ago`;
        if (diffHours < 24) return `${diffHours}h ago`;
        if (diffDays < 7) return `${diffDays}d ago`;
        return date.toLocaleDateString();
    } catch (err) {
        return '';
    }
}

// toggleNotificationCenter removed - now handled by Alpine.js @click directive
// Alpine.js automatically handles click-outside via @click.outside directive

async function markNotificationRead(notificationId) {
    try {
        await fetch(`/api/notifications/${notificationId}/read`, {
            method: 'POST',
            credentials: 'include',
            headers: getAuthHeaders()
        });
        loadNotificationCenter();
    } catch (err) {
        console.error('Failed to mark notification as read:', err);
    }
}

async function markAllNotificationsRead() {
    try {
        await fetch('/api/notifications/mark-all-read', {
            method: 'POST',
            credentials: 'include',
            headers: getAuthHeaders()
        });
        loadNotificationCenter();
        showNotification('All notifications marked as read', 'success');
    } catch (err) {
        console.error('Failed to mark all as read:', err);
    }
}

async function clearAllNotifications() {
    if (!confirm('Clear all notifications? This cannot be undone.')) return;
    
    try {
        await fetch('/api/notifications/clear', {
            method: 'POST',
            credentials: 'include',
            headers: getAuthHeaders()
        });
        loadNotificationCenter();
        showNotification('All notifications cleared', 'success');
    } catch (err) {
        console.error('Failed to clear notifications:', err);
    }
}

async function deleteNotification(notificationId) {
    try {
        await fetch(`/api/notifications/${notificationId}`, {
            method: 'DELETE',
            credentials: 'include',
            headers: getAuthHeaders()
        });
        loadNotificationCenter();
    } catch (err) {
        console.error('Failed to delete notification:', err);
    }
}

// Enhanced showNotification with notification center integration
// (Note: original showNotification is defined earlier in the script)
function showNotificationWithHistory(message, type) {
    // Base showNotification already persists to Notification Center.
    // Call it directly to avoid duplicate entries or toasts.
    showNotification(message, type);
}

// Keyboard Shortcuts and Command Palette
const commands = [
    { name: 'Toggle Dark Mode', icon: 'bi-moon-stars', shortcut: 'Ctrl+D', action: () => toggleTheme() },
    { name: 'Refresh Dashboard', icon: 'bi-arrow-clockwise', shortcut: 'Ctrl+R', action: () => location.reload() },
    { name: 'Open Notifications', icon: 'bi-bell', shortcut: 'Ctrl+N', action: () => toggleNotificationCenter() },
    { name: 'Show Keyboard Shortcuts', icon: 'bi-keyboard', shortcut: '?', action: () => showHelpModal() },
    { name: 'View Changelog', icon: 'bi-clock-history', shortcut: 'Ctrl+L', action: () => showChangelog() },
    { name: 'About Dashboard', icon: 'bi-info-circle', shortcut: 'Ctrl+H', action: () => showAboutModal() },
    { name: 'Go to Config Page', icon: 'bi-gear', shortcut: '', action: () => window.location.href = '/config' },
    { name: 'Refresh Statistics', icon: 'bi-graph-up', shortcut: '', action: () => loadStatistics() },
    { name: 'Reset Dashboard Layout', icon: 'bi-arrow-counterclockwise', shortcut: '', action: () => resetDashboardLayout() },
    { name: 'Show Hidden Modules', icon: 'bi-eye', shortcut: '', action: () => showHiddenModules() },
    { name: 'Logout', icon: 'bi-box-arrow-right', shortcut: '', action: () => logout() }
];

let selectedCommandIndex = 0;

// Global keyboard shortcut handler
document.addEventListener('keydown', function(e) {
    // Ctrl+K - Command Palette
    if (e.ctrlKey && e.key === 'k') {
        e.preventDefault();
        openCommandPalette();
        return;
    }
    
    // Ctrl+D - Toggle Dark Mode
    if (e.ctrlKey && e.key === 'd') {
        e.preventDefault();
        toggleTheme();
        return;
    }
    
    // Ctrl+R - Refresh (allow default but show notification)
    if (e.ctrlKey && e.key === 'r') {
        // Let browser handle refresh
        return;
    }
    
    // Ctrl+N - Open Notifications
    if (e.ctrlKey && e.key === 'n') {
        e.preventDefault();
        toggleNotificationCenter();
        return;
    }
    
    // Ctrl+L - Changelog
    if (e.ctrlKey && e.key === 'l') {
        e.preventDefault();
        showChangelog();
        return;
    }
    
    // Ctrl+H - About
    if (e.ctrlKey && e.key === 'h') {
        e.preventDefault();
        showAboutModal();
        return;
    }
    
    // ? - Show Help (when not in input field)
    if (e.key === '?' && !['INPUT', 'TEXTAREA'].includes(e.target.tagName)) {
        e.preventDefault();
        showHelpModal();
        return;
    }
    
    // Escape - Close all modals
    if (e.key === 'Escape') {
        closeCommandPalette();
        closeHelpModal();
        closeAboutModal();
        closeChangelogModal();
        closeIntroModal();
        if (notificationCenterOpen) {
            toggleNotificationCenter();
        }
        return;
    }
    
    // Arrow keys in command palette
    if (document.getElementById('command-palette-overlay').classList.contains('show')) {
        if (e.key === 'ArrowDown') {
            e.preventDefault();
            selectedCommandIndex = Math.min(selectedCommandIndex + 1, commands.length - 1);
            updateCommandSelection();
        } else if (e.key === 'ArrowUp') {
            e.preventDefault();
            selectedCommandIndex = Math.max(selectedCommandIndex - 1, 0);
            updateCommandSelection();
        } else if (e.key === 'Enter') {
            e.preventDefault();
            executeSelectedCommand();
        }
    }
});

function openCommandPalette() {
    const overlay = document.getElementById('command-palette-overlay');
    const input = document.getElementById('command-palette-input');
    overlay.classList.add('show');
    input.value = '';
    input.focus();
    selectedCommandIndex = 0;
    renderCommands(commands);
}

function closeCommandPalette() {
    const overlay = document.getElementById('command-palette-overlay');
    overlay.classList.remove('show');
}

function renderCommands(commandList) {
    const results = document.getElementById('command-palette-results');
    
    if (commandList.length === 0) {
        results.innerHTML = '<div class="command-palette-empty">No commands found</div>';
        return;
    }
    
    results.innerHTML = commandList.map((cmd, index) => `
        <div class="command-palette-item ${index === selectedCommandIndex ? 'selected' : ''}" 
             onclick="executeCommand(${index})" 
             data-index="${index}">
            <i class="bi ${cmd.icon}"></i>
            <span class="command-name">${cmd.name}</span>
            ${cmd.shortcut ? `<span class="command-shortcut">${cmd.shortcut}</span>` : ''}
        </div>
    `).join('');
}

function updateCommandSelection() {
    document.querySelectorAll('.command-palette-item').forEach((item, index) => {
        if (index === selectedCommandIndex) {
            item.classList.add('selected');
            item.scrollIntoView({ block: 'nearest' });
        } else {
            item.classList.remove('selected');
        }
    });
}

function executeCommand(index) {
    if (commands[index]) {
        closeCommandPalette();
        commands[index].action();
    }
}

function executeSelectedCommand() {
    executeCommand(selectedCommandIndex);
}

// Command palette search
document.getElementById('command-palette-input').addEventListener('input', function(e) {
    const query = e.target.value.toLowerCase();
    const filtered = commands.filter(cmd => 
        cmd.name.toLowerCase().includes(query) || 
        cmd.shortcut.toLowerCase().includes(query)
    );
    selectedCommandIndex = 0;
    renderCommands(filtered);
});

// ⚠️ DEPRECATION NOTICES - Framework Modernization Campaign
// ============================================================================
// This section documents legacy functions maintained for backward compatibility.
// These functions use manual DOM manipulation (classList.add/remove) and manual
// state management. They should be gradually migrated to Alpine.js directives.
//
// Migration Status:
// ✅ Completed: notification-center, intro-modal, module-hide/show, mobile-collapse
// 🔄 Pending: help-modal, about-modal, changelog-modal, login-modal (Bootstrap)
// 📋 To Consider: Sidebar state management, theme toggle, keyboard shortcuts
//
// New Alpine.js Pattern:
// Instead of:   element.classList.add('show')
// Use:          x-show="isOpen" in HTML + Alpine reactive state
//
// Benefits:
// - Reduces ~30 lines of JavaScript per modal
// - Eliminates manual event listener setup/teardown
// - Automatic click-outside handling with @click.outside
// - Reactive state persists between page navigations
// - Smoother transitions with x-transition directives
// ============================================================================

// Help Modal Functions
function showHelpModal() {
    console.warn('showHelpModal() uses classList - candidate for Alpine.js migration');
    document.getElementById('help-modal-overlay').classList.add('show');
}

function closeHelpModal() {
    console.warn('closeHelpModal() uses classList - candidate for Alpine.js migration');
    document.getElementById('help-modal-overlay').classList.remove('show');
}

// About Modal Functions
function showAboutModal() {
    console.warn('showAboutModal() uses classList - candidate for Alpine.js migration');
    document.getElementById('about-modal-overlay').classList.add('show');
}

function closeAboutModal() {
    console.warn('closeAboutModal() uses classList - candidate for Alpine.js migration');
    document.getElementById('about-modal-overlay').classList.remove('show');
}

// Changelog Functions
async function showChangelog() {
    const overlay = document.getElementById('changelog-modal-overlay');
    const content = document.getElementById('changelog-content');
    
    overlay.classList.add('show');
    
    try {
        const response = await fetch('/CHANGELOG.md');
        if (response.ok) {
            let markdown = await response.text();
            // Simple markdown to HTML conversion
            content.innerHTML = markdownToHtml(markdown);
        } else {
            content.innerHTML = '<p class="text-danger">Failed to load changelog.</p>';
        }
    } catch (err) {
        content.innerHTML = '<p class="text-danger">Error loading changelog: ' + err.message + '</p>';
    }
}

function closeChangelogModal() {
    document.getElementById('changelog-modal-overlay').classList.remove('show');
}

function markdownToHtml(markdown) {
    return markdown
        .replace(/^### (.+)$/gm, '<h5 class="mt-3">$1</h5>')
        .replace(/^## (.+)$/gm, '<h4 class="mt-4">$1</h4>')
        .replace(/^# (.+)$/gm, '<h3 class="mt-4">$1</h3>')
        .replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>')
        .replace(/\*(.+?)\*/g, '<em>$1</em>')
        .replace(/^- (.+)$/gm, '<li>$1</li>')
        .replace(/(<li>.*<\/li>\n?)+/g, '<ul>$&</ul>')
        .replace(/\n\n/g, '</p><p>')
        .replace(/^(?!<[h|u|l])/gm, '<p>')
        .replace(/(?<![>])$/gm, '</p>')
        .replace(/<p><\/p>/g, '')
        .replace(/\[([^\]]+)\]\(([^)]+)\)/g, '<a href="$2" target="_blank">$1</a>');
}

// ⚠️ DEPRECATED: Intro modal is now managed by Alpine.js
// Modal visibility and checkbox state handled by x-data and x-show directives
// See: dash/dashboard_base.html - intro-modal-overlay Alpine.js setup

// LEGACY: Replaced by Alpine.js on init and localStorage syncing
function checkShowIntro() {
    console.warn('checkShowIntro() is deprecated - Alpine.js manages intro modal visibility');
    // Alpine.js handles this on initialization
}

// LEGACY: Replaced by Alpine.js @click handler
function closeIntroModal() {
    console.warn('closeIntroModal() is deprecated - Alpine.js handles modal dismissal');
    // Alpine.js handles both dismissal and localStorage persistence
}

// ⚠️ DEPRECATED: Mobile collapsible functionality is now managed by Alpine.js
// Card collapse state is handled by Alpine.js @click directives with x-data tracking
// See: dash/dashboard.html - card-header Alpine.js setup for modules

// LEGACY: Replaced by Alpine.js @click and x-data directives
function initMobileCollapsible() {
    console.warn('initMobileCollapsible() is deprecated - Alpine.js handles collapse state declaratively');
    // No-op: Alpine.js handles this automatically
}

// Note: Mobile collapsible cards are now managed by Alpine.js with x-data and @click directives
console.log('Framework modernization: Mobile collapse handled by Alpine.js');
</script>
<script>
// Note: Service control functions MIGRATED TO HTMX
// Service control (Start/Stop/Restart) now uses htmx attributes for:
// - Declarative POST requests (hx-post="/start")
// - Automatic loading indicators (hx-indicator)
// - Auto status refresh (hx-on::after-request with refresh-status trigger)
// Removed: startService(), stopService(), restartService(), serviceAction(), updateServiceStatus()

// Export implementations to window for inline handlers
(function(){
    const exportNames = [
        'promptLogin','logout','resetDashboardLayout','addCustomWidget','editCustomWidget','removeCustomWidget',
        'saveCustomWidgets','loadCustomWidgets','initSidebarResizer','initDragAndDrop','saveDashboardLayout','loadDashboardLayout',
        'showNotification','toggleNotificationCenter','markAllNotificationsRead','clearAllNotifications',
        'revealPublicIP','hidePublicIP','extractPublicIP','copyPublicIP',
        'loadDuplicates','loadWatchedFolders','refreshRecentFiles','copyServiceName','copyToClipboard','deleteRow',
        'toggleHideModule','saveSettings','addCategoryRow','saveConfiguration','addCustomRouteRow','addTagRouteRow',
        'devResetToSetup','initResizableTables','initMobileCollapsible','updateServiceStatus',
        'showHiddenModules','loadDeveloperMode',
        'updateSidebarMetrics','updateSidebarStats','openStatsWindow','streamLog'
    ];
    exportNames.forEach(function(name){
        try {
            if (typeof window[name] !== 'function' && typeof eval(name) === 'function') {
                window[name] = eval(name);
            }
        } catch(e) {}
    });
})();
</script>
<script>
// Bind UI events to real implementations (rewire from inline handlers)
document.addEventListener('DOMContentLoaded', function(){
    const byId = (id)=>document.getElementById(id);
    const bind = (id, handler)=>{ const el = byId(id); if(el && typeof handler === 'function') el.addEventListener('click', handler); };

    // Auth & main controls
    bind('login-btn', window.promptLogin);
    bind('login-btn-sidebar', window.promptLogin);
    bind('logout-btn', window.logout);
    bind('logout-btn-sidebar', window.logout);
    bind('btn-show-hidden', window.showHiddenModules);
    bind('btn-reset-layout', window.resetDashboardLayout);
    bind('btn-add-widget', window.addCustomWidget);
    bind('reset-layout-btn', window.resetDashboardLayout);
    bind('show-hidden-btn', window.showHiddenModules);
    bind('dev-reset-btn', window.devResetToSetup);
    bind('dev-reset-btn-sidebar', window.devResetToSetup);
    
    // Service controls - MIGRATED TO HTMX
    // Start/Stop/Restart buttons now use htmx attributes (hx-post="/start" etc.)
    // Status updates via htmx refresh-status event trigger
    bind('service-name-btn', window.copyServiceName);
    
    // Module actions
    bind('btn-duplicates-refresh', window.loadDuplicates);
    bind('btn-recent-refresh', window.refreshRecentFiles);
    bind('btn-save-settings', window.saveSettings);
    bind('btn-add-category', window.addCategoryRow);
    bind('btn-save-config', window.saveConfiguration);
    bind('btn-add-custom-route', window.addCustomRouteRow);
    bind('btn-save-custom-routes', window.saveConfiguration);
    bind('btn-add-tag-route', window.addTagRouteRow);
    bind('btn-save-tag-routes', window.saveConfiguration);
    
    // Event delegation for hide toggles (data-module attribute)
    document.addEventListener('click', function(e){
        const toggle = e.target.closest('.hide-toggle');
        if(toggle && toggle.dataset.module && typeof window.toggleHideModule === 'function'){
            window.toggleHideModule(toggle.dataset.module);
        }
        
        // Delete row buttons (onclick="deleteRow(this)")
        if(e.target.matches('button') && e.target.textContent.trim() === 'Delete' && typeof window.deleteRow === 'function'){
            window.deleteRow(e.target);
        }
        
        // Copy-value spans with copyToClipboard
        const copySpan = e.target.closest('.copy-value');
        if(copySpan && typeof window.copyToClipboard === 'function'){
            const text = copySpan.textContent.trim();
            window.copyToClipboard(text, copySpan);
        }
    });
    
    // Public IP hover/out events
    const publicIpSpan = byId('public-ip-display');
    if(publicIpSpan){
        publicIpSpan.addEventListener('mouseover', window.revealPublicIP);
        publicIpSpan.addEventListener('mouseout', window.hidePublicIP);
        publicIpSpan.addEventListener('click', function(){ if(typeof window.copyPublicIP === 'function') window.copyPublicIP(this); });
    }
    
    // Extract public IP iframe onload
    const ipFrame = byId('ipchicken-frame');
    if(ipFrame && typeof window.extractPublicIP === 'function'){
        ipFrame.addEventListener('load', window.extractPublicIP);
    }
    
    // Load persisted theme on page load
    if (typeof restorePersistedTheme === 'function') {
        restorePersistedTheme();
    }
});

// ==================== THEME PERSISTENCE ====================
// Theme persistence system using localStorage with server-side backup

const THEME_STORAGE_KEY = 'dashboard_theme_v1';
const THEME_SYNC_INTERVAL = 30000; // Sync every 30 seconds

/**
 * Save theme to localStorage immediately
 * Queue for server sync in background
 */
function persistThemeLocally(theme) {
    if (!theme) return;
    
    try {
        // Save to localStorage for instant availability
        const themeData = {
            timestamp: Date.now(),
            theme: theme,
            version: 1
        };
        localStorage.setItem(THEME_STORAGE_KEY, JSON.stringify(themeData));
        
        // Queue for server sync
        scheduleThemeSync(theme);
    } catch (e) {
        console.warn('Failed to save theme to localStorage:', e);
    }
}

/**
 * Retrieve theme from localStorage
 */
function getPersistedTheme() {
    try {
        const stored = localStorage.getItem(THEME_STORAGE_KEY);
        if (!stored) return null;
        
        const data = JSON.parse(stored);
        if (data && data.theme) {
            return data.theme;
        }
    } catch (e) {
        console.warn('Failed to read theme from localStorage:', e);
    }
    return null;
}

/**
 * Schedule theme sync to server
 * Batches requests to avoid excessive API calls
 */
let themeSyncTimeout = null;
function scheduleThemeSync(theme) {
    if (themeSyncTimeout) {
        clearTimeout(themeSyncTimeout);
    }
    
    themeSyncTimeout = setTimeout(() => {
        syncThemeToServer(theme);
    }, 2000); // Wait 2 seconds for additional changes
}

/**
 * Sync current theme to server
 */
function syncThemeToServer(theme) {
    if (!theme || !__authHeader) return; // Don't sync if not authenticated
    
    fetch('/api/dashboard/branding', {
        method: 'POST',
        headers: {'Content-Type': 'application/json', ...getAuthHeaders()},
        body: JSON.stringify(theme)
    })
    .then(r => r.json().then(j => ({ok: r.ok, j})))
    .then(({ok, j}) => {
        if (!ok) {
            console.warn('Failed to sync theme to server:', j.error);
        }
    })
    .catch(e => console.warn('Error syncing theme to server:', e));
}

/**
 * Load theme from server (for first-time page load or after login)
 */
function loadThemeFromServer() {
    if (!__authHeader) {
        // User not authenticated, use localStorage only
        return;
    }
    
    return fetch('/api/dashboard/branding', {headers: getAuthHeaders()})
        .then(r => r.ok ? r.json() : null)
        .then(serverTheme => {
            if (serverTheme) {
                // Save server theme to localStorage
                persistThemeLocally(serverTheme);
                // Load the logo from the theme
                loadDashboardLogo(serverTheme);
                return serverTheme;
            }
            return null;
        })
        .catch(e => {
            console.warn('Error loading theme from server:', e);
            return null;
        });
}

/**
 * Load custom branding logo from theme configuration
 */
function loadDashboardLogo(theme) {
    const logoImg = document.getElementById('dashboard-logo');
    if (!logoImg) return;
    
    if (theme && theme.logo) {
        // Use custom logo from theme
        logoImg.src = theme.logo;
        logoImg.alt = theme.title || 'Dashboard Logo';
        logoImg.style.opacity = '1';
    } else {
        // Use default placeholder icon
        logoImg.style.opacity = '0.5';
    }
}

/**
 * Update dashboard logo when theme is changed (called from theme update functions)
 */
function updateDashboardLogo(theme) {
    loadDashboardLogo(theme);
}

/**
 * Restore persisted theme on page load
 * Strategy:
 * 1. Check localStorage first (fastest, works offline)
 * 2. If authenticated, try to load from server (might have updated on another device)
 * 3. Only apply server theme if it's NEWER than local theme (based on timestamp)
 */
async function restorePersistedTheme() {
    try {
        // Get theme from localStorage immediately
        const localTheme = getPersistedTheme();
        const localTimestamp = localTheme ? (localTheme.timestamp || 0) : 0;
        
        if (localTheme) {
            // Apply localStorage theme immediately (no delay)
            if (typeof applyThemeStyles === 'function') {
                applyThemeStyles(localTheme);
            }
            // Load logo from local theme
            if (typeof loadDashboardLogo === 'function') {
                loadDashboardLogo(localTheme);
            }
        }
        
        // If authenticated, try to load server theme in background
        if (__authHeader) {
            const serverTheme = await loadThemeFromServer();
            if (serverTheme) {
                const serverTimestamp = serverTheme.timestamp || 0;
                
                // Only apply server theme if it's NEWER than local theme
                if (serverTimestamp > localTimestamp) {
                    console.log('[Theme] Server theme is newer, applying server version');
                    updateThemeFormFields(serverTheme);
                    if (typeof applyThemeStyles === 'function') {
                        applyThemeStyles(serverTheme);
                    }
                    // Save server theme to localStorage
                    persistThemeLocally(serverTheme);
                } else {
                    console.log('[Theme] Local theme is up-to-date, keeping local version');
                    // Update form fields from local theme but don't re-apply styles
                    updateThemeFormFields(localTheme);
                }
            }
        }
    } catch (e) {
        console.warn('Error restoring persisted theme:', e);
    }
}

/**
 * Update theme form fields without re-loading from server
 * (Used when theme is synced from another tab/device)
 */
function updateThemeFormFields(theme) {
    if (!theme) return;
    
    try {
        theme.colors = theme.colors || {};
        theme.borderRadius = theme.borderRadius || '8px';
        theme.fontSize = theme.fontSize || '100%';
        theme.shadow = theme.shadow || 'normal';
        
        // Update form fields if they exist (might be on different page)
        const titleEl = document.getElementById('brand-title');
        if (titleEl && theme.title) titleEl.value = theme.title;
        
        const logoEl = document.getElementById('brand-logo');
        if (logoEl && theme.logo) logoEl.value = theme.logo;
        
        const nameEl = document.getElementById('brand-theme-name');
        if (nameEl && theme.themeName) nameEl.value = theme.themeName;
        
        const primaryEl = document.getElementById('brand-color-primary');
        if (primaryEl) {
            primaryEl.value = theme.colors.primary || '#0d6efd';
            if (typeof updateColorSwatchBackground === 'function') {
                updateColorSwatchBackground(primaryEl);
            }
        }
        
        const secondaryEl = document.getElementById('brand-color-secondary');
        if (secondaryEl) {
            secondaryEl.value = theme.colors.secondary || '#6c757d';
            if (typeof updateColorSwatchBackground === 'function') {
                updateColorSwatchBackground(secondaryEl);
            }
        }
        
        const successEl = document.getElementById('brand-color-success');
        if (successEl) {
            successEl.value = theme.colors.success || '#198754';
            if (typeof updateColorSwatchBackground === 'function') {
                updateColorSwatchBackground(successEl);
            }
        }
        
        const dangerEl = document.getElementById('brand-color-danger');
        if (dangerEl) {
            dangerEl.value = theme.colors.danger || '#dc3545';
            if (typeof updateColorSwatchBackground === 'function') {
                updateColorSwatchBackground(dangerEl);
            }
        }
        
        const warningEl = document.getElementById('brand-color-warning');
        if (warningEl) {
            warningEl.value = theme.colors.warning || '#ffc107';
            if (typeof updateColorSwatchBackground === 'function') {
                updateColorSwatchBackground(warningEl);
            }
        }
        
        const infoEl = document.getElementById('brand-color-info');
        if (infoEl) {
            infoEl.value = theme.colors.info || '#0dcaf0';
            if (typeof updateColorSwatchBackground === 'function') {
                updateColorSwatchBackground(infoEl);
            }
        }
        
        const radiusEl = document.getElementById('brand-border-radius');
        if (radiusEl) radiusEl.value = theme.borderRadius;
        
        const fontEl = document.getElementById('brand-font-size');
        if (fontEl) fontEl.value = theme.fontSize;
        
        const shadowEl = document.getElementById('brand-shadow');
        if (shadowEl) shadowEl.value = theme.shadow;
        
        const cssEl = document.getElementById('brand-css');
        if (cssEl && theme.css) cssEl.value = theme.css;
    } catch (e) {
        console.warn('Error updating theme form fields:', e);
    }
}

/**
 * Override saveBranding to also persist locally
 * (This extends the existing saveBranding function)
 */
const originalSaveBranding = window.saveBranding;
if (typeof originalSaveBranding === 'function') {
    window.saveBranding = function() {
        // Call original save
        originalSaveBranding.call(this);
        
        // Also persist to localStorage after a brief delay
        setTimeout(() => {
            const theme = getThemeObject ? getThemeObject() : null;
            if (theme) {
                persistThemeLocally(theme);
            }
        }, 500);
    };
}

/**
 * Clear persisted theme
 */
function clearPersistedTheme() {
    try {
        localStorage.removeItem(THEME_STORAGE_KEY);
    } catch (e) {
        console.warn('Failed to clear persisted theme:', e);
    }
}

/**
 * Export current persisted theme data
 */
function exportPersistedTheme() {
    const theme = getPersistedTheme();
    if (!theme) {
        console.warn('No persisted theme found');
        return null;
    }
    return theme;
}

/**
 * Sync theme across browser tabs
 * Listens for localStorage changes from other tabs
 */
window.addEventListener('storage', function(e) {
    if (e.key === THEME_STORAGE_KEY && e.newValue) {
        try {
            const data = JSON.parse(e.newValue);
            if (data && data.theme) {
                console.log('Theme updated from another tab');
                updateThemeFormFields(data.theme);
                if (typeof applyThemeStyles === 'function') {
                    applyThemeStyles(data.theme);
                }
            }
        } catch (err) {
            console.warn('Error syncing theme from another tab:', err);
        }
    }
});

// ==================== THEME STYLING FUNCTIONS ====================
// These functions apply theme colors to all dashboard elements

/**
 * Calculate if a color is light or dark for text contrast
 */
function isLightColor(hex) {
  if (!hex || typeof hex !== 'string') return true;
  const cleanHex = hex.replace('#', '').trim();
  if (!/^[0-9A-Fa-f]{6}$/.test(cleanHex)) return true;
  
  const num = parseInt(cleanHex, 16);
  const r = (num >> 16) & 255;
  const g = (num >> 8) & 255;
  const b = num & 255;
  
  // Calculate luminance using relative luminance formula
  const luminance = (0.299 * r + 0.587 * g + 0.114 * b) / 255;
  return luminance > 0.5;
}

/**
 * Get high contrast text color (white or dark gray) based on background
 */
function getContrastText(bgHex) {
  return isLightColor(bgHex) ? '#1a1a1a' : '#ffffff';
}

/**
 * Adjust color brightness
 */
function adjustColor(hex, percent) {
  if (!hex || typeof hex !== 'string') return '#0d6efd';
  const cleanHex = hex.replace('#', '').trim();
  if (!/^[0-9A-Fa-f]{6}$/.test(cleanHex)) return hex;
  
  const num = parseInt(cleanHex, 16);
  const amt = Math.round(2.55 * percent);
  const R = Math.max(0, Math.min(255, (num >> 16) + amt));
  const G = Math.max(0, Math.min(255, ((num >> 8) & 0x00FF) + amt));
  const B = Math.max(0, Math.min(255, (num & 0x0000FF) + amt));
  return '#' + (0x1000000 + (R << 16) + (G << 8) + B).toString(16).slice(1);
}

/**
 * Apply theme styles to the entire dashboard
 */
function applyThemeStyles(theme) {
  if (!theme) theme = {};
  if (!theme.colors) theme.colors = {};
  if (!theme.borderRadius) theme.borderRadius = '8px';
  if (!theme.fontSize) theme.fontSize = '100%';
  if (!theme.shadow) theme.shadow = 'normal';
  
  let style = document.getElementById('custom-theme-css');
  if (!style) {
    style = document.createElement('style');
    style.id = 'custom-theme-css';
    style.setAttribute('data-priority', 'high');
    document.head.appendChild(style);
  }
  
  const shadowMap = {
    none: 'none',
    light: '0 1px 3px rgba(0,0,0,0.1)',
    normal: '0 1px 3px rgba(0,0,0,0.12), 0 1px 2px rgba(0,0,0,0.24)',
    strong: '0 10px 40px rgba(0,0,0,0.3)'
  };
  
  const primary = theme.colors.primary || '#0d6efd';
  const secondary = theme.colors.secondary || '#6c757d';
  const success = theme.colors.success || '#198754';
  const danger = theme.colors.danger || '#dc3545';
  const warning = theme.colors.warning || '#ffc107';
  const info = theme.colors.info || '#0dcaf0';
  
  // Calculate text colors for high contrast
  const primaryText = getContrastText(primary);
  const secondaryText = getContrastText(secondary);
  const successText = getContrastText(success);
  const dangerText = getContrastText(danger);
  const warningText = getContrastText(warning);
  const infoText = getContrastText(info);
  
  // Calculate light background color (50% lighter version of primary for visible tint)
  const bgLight = adjustColor(primary, 50);
  const bgLightText = adjustColor(primary, -60);
  const bgDark = adjustColor(primary, -90);
  
  let css = `:root {
    --bs-primary: ${primary} !important;
    --bs-secondary: ${secondary} !important;
    --bs-success: ${success} !important;
    --bs-danger: ${danger} !important;
    --bs-warning: ${warning} !important;
    --bs-info: ${info} !important;
    --bs-light: ${bgLight} !important;
    --bs-dark: ${bgDark} !important;
    --bs-primary-text: ${primaryText} !important;
    --bs-secondary-text: ${secondaryText} !important;
    --bs-success-text: ${successText} !important;
    --bs-danger-text: ${dangerText} !important;
    --bs-warning-text: ${warningText} !important;
    --bs-info-text: ${infoText} !important;
  }
  
  /* Basic elements */
  .card { border-radius: ${theme.borderRadius} !important; box-shadow: ${shadowMap[theme.shadow] || shadowMap.normal} !important; }
  body { font-size: ${theme.fontSize} !important; }
  .bg-light { background-color: ${bgLight} !important; color: ${bgLightText} !important; }
  .bg-light .text-muted { color: ${adjustColor(primary, -40)} !important; }
  .bg-light .fw-bold { color: ${adjustColor(primary, -70)} !important; }
  .bg-light-text { color: ${bgLightText} !important; }
  .text-light { color: ${adjustColor(primary, -80)} !important; }
  
  /* Statistics cards - nested cards with bg-light */
  #org-stats .card.bg-light { 
    background-color: ${bgLight} !important; 
    color: ${adjustColor(primary, -70)} !important;
  }
  #org-stats .card.bg-light * { color: ${adjustColor(primary, -70)} !important; }
  #org-stats .card.bg-light small { color: ${adjustColor(primary, -60)} !important; }
  #org-stats .card.bg-light .text-muted { color: ${adjustColor(primary, -60)} !important; }
  #org-stats .card.bg-light .display-6 { color: ${adjustColor(primary, -80)} !important; }
  #org-stats .card.bg-light .fw-bold { color: ${adjustColor(primary, -80)} !important; }
  #org-stats .card.bg-light .h6 { color: ${adjustColor(primary, -80)} !important; }
  
  /* Primary button and elements */
  .btn-primary { background-color: ${primary} !important; border-color: ${primary} !important; color: ${primaryText} !important; }
  .btn-primary:hover { background-color: ${adjustColor(primary, -20)} !important; border-color: ${adjustColor(primary, -20)} !important; color: ${primaryText} !important; }
  .btn-primary:focus { color: ${primaryText} !important; }
  .btn-primary:active { color: ${primaryText} !important; }
  .btn-outline-primary { color: ${primary} !important; border-color: ${primary} !important; }
  .btn-outline-primary:hover { background-color: ${primary} !important; color: ${primaryText} !important; border-color: ${primary} !important; }
  
  /* Secondary button and elements */
  .btn-secondary { background-color: ${secondary} !important; border-color: ${secondary} !important; color: ${secondaryText} !important; }
  .btn-secondary:hover { background-color: ${adjustColor(secondary, -20)} !important; border-color: ${adjustColor(secondary, -20)} !important; color: ${secondaryText} !important; }
  .btn-outline-secondary { color: ${secondary} !important; border-color: ${secondary} !important; }
  .btn-outline-secondary:hover { background-color: ${secondary} !important; color: ${secondaryText} !important; border-color: ${secondary} !important; }
  
  /* Success button and elements */
  .btn-success { background-color: ${success} !important; border-color: ${success} !important; color: ${successText} !important; }
  .btn-success:hover { background-color: ${adjustColor(success, -20)} !important; border-color: ${adjustColor(success, -20)} !important; color: ${successText} !important; }
  .btn-outline-success { color: ${success} !important; border-color: ${success} !important; }
  .btn-outline-success:hover { background-color: ${success} !important; color: ${successText} !important; border-color: ${success} !important; }
  
  /* Danger button and elements */
  .btn-danger { background-color: ${danger} !important; border-color: ${danger} !important; color: ${dangerText} !important; }
  .btn-danger:hover { background-color: ${adjustColor(danger, -20)} !important; border-color: ${adjustColor(danger, -20)} !important; color: ${dangerText} !important; }
  .btn-outline-danger { color: ${danger} !important; border-color: ${danger} !important; }
  .btn-outline-danger:hover { background-color: ${danger} !important; color: ${dangerText} !important; border-color: ${danger} !important; }
  
  /* Warning button and elements */
  .btn-warning { background-color: ${warning} !important; border-color: ${warning} !important; color: ${warningText} !important; }
  .btn-warning:hover { background-color: ${adjustColor(warning, -20)} !important; border-color: ${adjustColor(warning, -20)} !important; color: ${warningText} !important; }
  .btn-outline-warning { color: ${warning} !important; border-color: ${warning} !important; }
  .btn-outline-warning:hover { background-color: ${warning} !important; color: ${warningText} !important; border-color: ${warning} !important; }
  
  /* Info button and elements */
  .btn-info { background-color: ${info} !important; border-color: ${info} !important; color: ${infoText} !important; }
  .btn-info:hover { background-color: ${adjustColor(info, -20)} !important; border-color: ${adjustColor(info, -20)} !important; color: ${infoText} !important; }
  .btn-outline-info { color: ${info} !important; border-color: ${info} !important; }
  .btn-outline-info:hover { background-color: ${info} !important; color: ${infoText} !important; border-color: ${info} !important; }
  
  /* Badge colors */
  .badge-primary { background-color: ${primary} !important; color: ${primaryText} !important; }
  .badge-secondary { background-color: ${secondary} !important; color: ${secondaryText} !important; }
  .badge-success { background-color: ${success} !important; color: ${successText} !important; }
  .badge-danger { background-color: ${danger} !important; color: ${dangerText} !important; }
  .badge-warning { background-color: ${warning} !important; color: ${warningText} !important; }
  .badge-info { background-color: ${info} !important; color: ${infoText} !important; }
  
  /* Alert colors */
  .alert-primary { background-color: ${adjustColor(primary, 90)} !important; border-color: ${primary} !important; color: ${adjustColor(primary, -70)} !important; }
  .alert-primary * { color: ${adjustColor(primary, -70)} !important; }
  .alert-secondary { background-color: ${adjustColor(secondary, 85)} !important; border-color: ${secondary} !important; color: ${adjustColor(secondary, -70)} !important; }
  .alert-secondary * { color: ${adjustColor(secondary, -70)} !important; }
  .alert-success { background-color: ${adjustColor(success, 85)} !important; border-color: ${success} !important; color: ${adjustColor(success, -70)} !important; }
  .alert-success * { color: ${adjustColor(success, -70)} !important; }
  .alert-danger { background-color: ${adjustColor(danger, 85)} !important; border-color: ${danger} !important; color: ${adjustColor(danger, -70)} !important; }
  .alert-danger * { color: ${adjustColor(danger, -70)} !important; }
  .alert-warning { background-color: ${adjustColor(warning, 85)} !important; border-color: ${warning} !important; color: ${adjustColor(warning, -70)} !important; }
  .alert-warning * { color: ${adjustColor(warning, -70)} !important; }
  .alert-info { background-color: ${adjustColor(info, 85)} !important; border-color: ${info} !important; color: ${adjustColor(info, -70)} !important; }
  .alert-info * { color: ${adjustColor(info, -70)} !important; }
  
  /* Card headers */
  .card-header { background-color: ${primary} !important; color: ${primaryText} !important; border-color: ${primary} !important; }
  .card-header .btn { color: ${primaryText} !important; }
  .card-header a { color: ${primaryText} !important; text-decoration: underline; }
  
  /* Links and text */
  a { color: ${primary} !important; }
  a:hover { color: ${adjustColor(primary, -20)} !important; }
  .text-primary { color: ${primary} !important; }
  .text-secondary { color: ${secondary} !important; }
  .text-success { color: ${success} !important; }
  .text-danger { color: ${danger} !important; }
  .text-warning { color: ${warning} !important; }
  .text-info { color: ${info} !important; }
  
  /* Muted text - use secondary color for better contrast in all themes */
  .text-muted { color: ${secondary} !important; }
  small.text-muted { color: ${secondary} !important; }
  
  /* Backgrounds with text */
  .bg-primary { background-color: ${primary} !important; color: ${primaryText} !important; }
  .bg-secondary { background-color: ${secondary} !important; color: ${secondaryText} !important; }
  .bg-success { background-color: ${success} !important; color: ${successText} !important; }
  .bg-danger { background-color: ${danger} !important; color: ${dangerText} !important; }
  .bg-warning { background-color: ${warning} !important; color: ${warningText} !important; }
  .bg-info { background-color: ${info} !important; color: ${infoText} !important; }
  
  /* Borders */
  .border { border-color: ${adjustColor(secondary, -30)} !important; }
  .border-primary { border-color: ${primary} !important; }
  .border-secondary { border-color: ${secondary} !important; }
  .border-success { border-color: ${success} !important; }
  .border-danger { border-color: ${danger} !important; }
  .border-warning { border-color: ${warning} !important; }
  .border-info { border-color: ${info} !important; }
  
  /* Progress bars */
  .progress-bar { background-color: ${primary} !important; }
  .bg-success .progress-bar { background-color: ${success} !important; }
  .bg-danger .progress-bar { background-color: ${danger} !important; }
  .bg-warning .progress-bar { background-color: ${warning} !important; }
  .bg-info .progress-bar { background-color: ${info} !important; }
  
  /* Table elements */
  .table-primary { background-color: ${adjustColor(primary, 85)} !important; }
  .table-secondary { background-color: ${adjustColor(secondary, 85)} !important; }
  .table-success { background-color: ${adjustColor(success, 85)} !important; }
  .table-danger { background-color: ${adjustColor(danger, 85)} !important; }
  .table-warning { background-color: ${adjustColor(warning, 85)} !important; }
  .table-info { background-color: ${adjustColor(info, 85)} !important; }
  .table-hover tbody tr:hover { background-color: ${adjustColor(primary, 90)} !important; }
  
  /* Form elements */
  .form-control:focus { border-color: ${primary} !important; box-shadow: 0 0 0 0.2rem ${adjustColor(primary, 85)} !important; }
  .form-control-color { border-color: ${primary} !important; }
  .form-check-input:checked { background-color: ${primary} !important; border-color: ${primary} !important; }
  .form-check-input:focus { border-color: ${primary} !important; box-shadow: 0 0 0 0.2rem ${adjustColor(primary, 85)} !important; }
  
  /* Status indicators */
  .status-active { color: ${success} !important; }
  .status-inactive { color: ${danger} !important; }
  .status-pending { color: ${warning} !important; }
  .status-info { color: ${info} !important; }
  
  /* List group */
  .list-group-item-primary { background-color: ${adjustColor(primary, 90)} !important; color: ${primary} !important; }
  .list-group-item-primary.active { background-color: ${primary} !important; color: ${primaryText} !important; border-color: ${primary} !important; }
  .list-group-item-success { background-color: ${adjustColor(success, 90)} !important; color: ${success} !important; }
  .list-group-item-success.active { background-color: ${success} !important; color: ${successText} !important; border-color: ${success} !important; }
  
  /* Navbar and tabs */
  .nav-tabs .nav-link.active { border-color: ${primary} !important; color: ${primary} !important; }
  .nav-pills .nav-link.active { background-color: ${primary} !important; color: ${primaryText} !important; }
  
  /* Breadcrumb */
  .breadcrumb { background-color: ${bgLight} !important; }
  .breadcrumb .active { color: ${primary} !important; }
  
  /* Pagination */
  .page-link { color: ${primary} !important; }
  .page-link:hover { background-color: ${bgLight} !important; }
  .page-item.active .page-link { background-color: ${primary} !important; border-color: ${primary} !important; color: ${primaryText} !important; }
  
  /* Spinners and loaders */
  .spinner-border { border-color: ${bgLight} !important; border-right-color: ${primary} !important; }
  .spinner-grow { background-color: ${primary} !important; }
  `;
  
  if (theme.css) {
    css += '\n' + theme.css;
  }
  
  style.textContent = css;
  
  // Update dashboard logo when theme is applied
  if (typeof updateDashboardLogo === 'function') {
    updateDashboardLogo(theme);
  }
  
  // CRITICAL: Force inline styles on statistics cards (Bootstrap defaults are too strong)
  forceStatisticsCardsTheme(theme);
}

/**
 * Force theme colors onto statistics cards using inline styles
 * This is necessary because Bootstrap's .bg-light has !important and wins over CSS
 */
function forceStatisticsCardsTheme(theme) {
  // Wait a moment for DOM to be ready
  setTimeout(() => {
    const primary = theme.colors?.primary || '#0d6efd';
    const bgLight = adjustColor(primary, 50);  // Lightened for visible theme tint
    const labelColor = adjustColor(primary, -60);
    const numberColor = adjustColor(primary, -80);
    
    // Target all cards in the org-stats section
    const statsCards = document.querySelectorAll('#org-stats .card.bg-light');
    
    statsCards.forEach(card => {
      card.style.backgroundColor = bgLight;
      card.style.color = labelColor;
      card.style.borderColor = adjustColor(primary, 70);
      
      // Force styles on all nested elements
      card.querySelectorAll('small, .text-muted').forEach(el => {
        el.style.color = labelColor;
      });
      
      card.querySelectorAll('.display-6, .fw-bold, .h6').forEach(el => {
        el.style.color = numberColor;
      });
    });
  }, 50);
}

// Mobile Drawer Navigation
function toggleDrawer() {
    const sidebar = document.getElementById('sidebar');
    const backdrop = document.getElementById('drawer-backdrop');
    const toggle = document.getElementById('drawer-toggle');
    
    if (!sidebar || !backdrop) return;
    
    sidebar.classList.toggle('drawer-open');
    backdrop.classList.toggle('show');
    if (toggle) toggle.classList.toggle('active');
}

// Close drawer when clicking on links inside it
function closeDrawerOnLinkClick() {
    const sidebar = document.getElementById('sidebar');
    if (!sidebar.classList.contains('drawer-open')) return;
    
    const links = sidebar.querySelectorAll('a, button');
    links.forEach(link => {
        link.addEventListener('click', (e) => {
            // Don't close if it's a button that doesn't navigate
            if (link.tagName === 'BUTTON' && !link.getAttribute('onclick')?.includes('location')) {
                return;
            }
            // Check if it's an external link or config page
            const href = link.getAttribute('href');
            if (href && !href.startsWith('#')) {
                setTimeout(toggleDrawer, 100);
            }
        });
    });
}

// Update resource summary from metrics
async function updateResourceSummary() {
    try {
        const response = await fetch('/metrics', {
            headers: getAuthHeaders ? getAuthHeaders() : {}
        });
        if (response.ok) {
            const data = await response.json();
            
            // Update memory display - API returns total_memory_mb and total_memory_gb
            const memUsed = document.getElementById('mem-used');
            const memTotal = document.getElementById('mem-total');
            if (memUsed && memTotal) {
                const used = data.total_memory_mb ? (data.total_memory_mb / 1024).toFixed(2) : '-';
                const total = data.total_memory_gb ? data.total_memory_gb.toFixed(2) : '-';
                memUsed.textContent = used;
                memTotal.textContent = total;
            }
            
            // Update disk display - now included in /metrics response
            const diskUsed = document.getElementById('disk-used');
            const diskTotal = document.getElementById('disk-total');
            if (diskUsed && diskTotal) {
                const used = data.disk_used_gb ? data.disk_used_gb.toFixed(2) : 'N/A';
                const total = data.disk_total_gb ? data.disk_total_gb.toFixed(2) : 'N/A';
                diskUsed.textContent = used;
                diskTotal.textContent = total;
            }
            
            // Update timestamp
            const timestamp = document.getElementById('metric-timestamp');
            if (timestamp) {
                const now = new Date();
                timestamp.textContent = now.toLocaleTimeString();
            }
        }
    } catch (error) {
        console.debug('Could not update resource summary:', error);
    }
}

// Initialize drawer on page load
document.addEventListener('DOMContentLoaded', () => {
    closeDrawerOnLinkClick();
    
    // Update resource summary immediately and every 5 seconds
    updateResourceSummary();
    setInterval(updateResourceSummary, 5000);
    
    // Close drawer on escape key
    document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape') {
            const sidebar = document.getElementById('sidebar');
            if (sidebar?.classList.contains('drawer-open')) {
                toggleDrawer();
            }
        }
    });
});
</script>


