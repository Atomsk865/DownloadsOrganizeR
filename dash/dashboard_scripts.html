<!-- Bootstrap JS -->
<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js"></script>
<!-- Chart.js -->
<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
<!-- Login / Change-password Modal -->
<div class="modal fade" id="loginModal" tabindex="-1" aria-labelledby="loginModalLabel" aria-hidden="true" role="dialog">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title" id="loginModalLabel">Dashboard Login</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <div class="mb-2">
                    <label for="login-username" class="form-label">Username</label>
                    <input id="login-username" class="form-control" type="text" value="admin">
                </div>
                <div class="mb-2">
                    <label for="login-password" class="form-label">Password</label>
                    <input id="login-password" class="form-control" type="password">
                </div>
                <div id="change-password-section" style="display:none;">
                    <hr>
                    <div class="mb-2">
                        <label class="form-label">New password</label>
                        <input id="new-password" class="form-control" type="password">
                    </div>
                    <div class="mb-2">
                        <label class="form-label">Confirm new password</label>
                        <input id="confirm-password" class="form-control" type="password">
                    </div>
                </div>
                <div id="login-error" class="text-danger" style="display:none;"></div>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                <button id="login-submit" type="button" class="btn btn-primary">Login</button>
                <button id="change-submit" type="button" class="btn btn-success" style="display:none;">Change Password</button>
            </div>
        </div>
    </div>
</div>
<script>
// Global auth header storage
let __authHeader = null;
let __rights = {};
let __configVersion = 0;
let __rightsPollIntervalMs = 60000; // 60s polling
let __csrfToken = null;
let __organizerFeatures = { virustotal_enabled: true, duplicates_enabled: true, reports_enabled: true };
let __vtApiKey = '';

// Fetch CSRF token on page load
async function fetchCSRFToken() {
    try {
        const resp = await fetch('/api/csrf-token', { credentials: 'include' });
        if (resp.ok) {
            const data = await resp.json();
            __csrfToken = data.csrf_token;
        }
    } catch (e) {
        console.warn('Failed to fetch CSRF token:', e);
    }
}

// Sidebar resizer logic (top-level)
function initSidebarResizer() {
    const resizer = document.getElementById('sidebar-resizer');
    const container = document.querySelector('.dashboard-container');
    if (!resizer || !container) return;

    // Restore saved width
    const saved = localStorage.getItem('sidebarWidth');
    if (saved) {
        document.documentElement.style.setProperty('--sidebar-width', saved);
    }

    let startX = 0;
    function onMouseDown(e) {
        startX = e.clientX;
        resizer.classList.add('active');
        document.body.style.cursor = 'col-resize';
        document.addEventListener('mousemove', onMouseMove);
        document.addEventListener('mouseup', onMouseUp);
    }

    function onMouseMove(e) {
        const rect = container.getBoundingClientRect();
        const diffPx = e.clientX - rect.left;
        let pct = (diffPx / rect.width) * 100;
        pct = Math.max(15, Math.min(35, pct)); // clamp between 15% and 35%
        const pctStr = pct.toFixed(1) + '%';
        document.documentElement.style.setProperty('--sidebar-width', pctStr);
    }

    function onMouseUp() {
        resizer.classList.remove('active');
        document.body.style.cursor = '';
        document.removeEventListener('mousemove', onMouseMove);
        document.removeEventListener('mouseup', onMouseUp);
        const current = getComputedStyle(document.documentElement).getPropertyValue('--sidebar-width').trim();
        try { localStorage.setItem('sidebarWidth', current); } catch(e) {}
    }

    resizer.addEventListener('mousedown', onMouseDown);

    // Double-click to cycle presets
    const presets = [15, 20, 25, 30, 35];
    resizer.addEventListener('dblclick', function() {
        const currentStr = getComputedStyle(document.documentElement).getPropertyValue('--sidebar-width').trim() || '20%';
        const current = parseFloat(currentStr);
        let idx = presets.findIndex(p => Math.abs(p - current) < 0.51);
        idx = (idx + 1) % presets.length;
        const nextPct = presets[idx];
        const pctStr = nextPct.toFixed(0) + '%';
        document.documentElement.style.setProperty('--sidebar-width', pctStr);
        try { localStorage.setItem('sidebarWidth', pctStr); } catch(e) {}
    });
}

// Login functionality
function promptLogin() {
    document.getElementById('change-password-section').style.display = 'none';
    document.getElementById('login-submit').style.display = 'inline-block';
    document.getElementById('change-submit').style.display = 'none';
    document.getElementById('login-error').style.display = 'none';
    document.getElementById('login-password').value = '';
    const modal = new bootstrap.Modal(document.getElementById('loginModal'));
    modal.show();
}

function logout() {
    __authHeader = null;
    // Clear stored credentials
    try {
        sessionStorage.removeItem('authHeader');
    } catch (e) {}
    // Remove cookie
    document.cookie = 'authHeader=; Max-Age=0; Path=/; SameSite=Lax' + (location.protocol === 'https:' ? '; Secure' : '');
    document.getElementById('login-btn').classList.remove('d-none');
    document.getElementById('logout-btn').classList.add('d-none');
    document.getElementById('config-link').classList.add('d-none');
    showNotification('Logged out successfully', 'info');
}

document.getElementById('login-submit').addEventListener('click', async function() {
    const username = document.getElementById('login-username').value;
    const password = document.getElementById('login-password').value;
    const credentials = btoa(username + ':' + password);
    __authHeader = 'Basic ' + credentials;
    
    // Store credentials in sessionStorage and cookie for persistence
    try {
        sessionStorage.setItem('authHeader', __authHeader);
    } catch (e) {
        console.warn('sessionStorage not available:', e);
    }
    // Persist for 14 days in cookie
    document.cookie = 'authHeader=' + encodeURIComponent(__authHeader) + '; Max-Age=' + (14*24*60*60) + '; Path=/; SameSite=Lax' + (location.protocol === 'https:' ? '; Secure' : '');
    
    try {
        const response = await fetch('/auth_check', {
            credentials: 'include',
            headers: { 'Authorization': __authHeader }
        });
        
        if (response.ok) {
            const data = await response.json();
            __rights = data.rights || {};
            __configVersion = data.config_version || 0;
            bootstrap.Modal.getInstance(document.getElementById('loginModal')).hide();
            document.getElementById('login-btn').classList.add('d-none');
            document.getElementById('logout-btn').classList.remove('d-none');
            // Show config link if user has manage_config or modify_layout rights
            if (__rights.manage_config || __rights.modify_layout) {
                document.getElementById('config-link').classList.remove('d-none');
            }
            showNotification('Login successful', 'success');
            applyRights();
            // Show reset layout button after login
            const resetBtn = document.getElementById('reset-layout-btn');
            if (resetBtn) resetBtn.classList.remove('d-none');
            // Reload user-specific layout and widgets
            loadDashboardLayout();
            loadCustomWidgets();
            initResizableTables();
            syncAuthButtons();
            initSidebarResizer();
            initMobileCollapsible();
            updateServiceStatus();
        } else {
            document.getElementById('login-error').textContent = 'Invalid credentials';
            document.getElementById('login-error').style.display = 'block';
            __authHeader = null;
        }
    } catch (error) {
        document.getElementById('login-error').textContent = 'Login failed: ' + error.message;
        document.getElementById('login-error').style.display = 'block';
        __authHeader = null;
    }
});

function getAuthHeaders() {
    const headers = __authHeader ? { 'Authorization': __authHeader } : {};
    if (__csrfToken) {
        headers['X-CSRFToken'] = __csrfToken;
    }
    return headers;
}

// Drag & Drop for Dashboard Modules with Visual Indicators
let draggedElement = null;

function initDragAndDrop() {
    const modules = document.querySelectorAll('.dashboard-module[draggable="true"]');
    modules.forEach(module => {
        if (module.dataset.dragInit === 'true') return;
        module.dataset.dragInit = 'true';
        module.dataset.dragHandleActive = 'false';

        module.addEventListener('mousedown', function(e) {
            this.dataset.dragHandleActive = e.target.closest('.drag-handle') ? 'true' : 'false';
        });
        module.addEventListener('mouseup', function() {
            this.dataset.dragHandleActive = 'false';
        });
        module.addEventListener('mouseleave', function() {
            this.dataset.dragHandleActive = 'false';
        });

        module.addEventListener('dragstart', handleDragStart);
        module.addEventListener('dragover', handleDragOver);
        module.addEventListener('dragenter', handleDragEnter);
        module.addEventListener('dragleave', handleDragLeave);
        module.addEventListener('drop', handleDrop);
        module.addEventListener('dragend', handleDragEnd);
    });
}

function handleDragStart(e) {
    if (this.dataset.dragHandleActive !== 'true') {
        draggedElement = null;
        e.preventDefault();
        return false;
    }
    draggedElement = this;
    this.classList.add('dragging');
    this.dataset.dragHandleActive = 'false';
    e.dataTransfer.effectAllowed = 'move';
    e.dataTransfer.setData('text/html', this.innerHTML);
    
    // Add visual feedback to other modules
    setTimeout(() => {
        document.querySelectorAll('.dashboard-module:not(.dragging)').forEach(m => {
            m.style.opacity = '0.7';
        });
    }, 0);
}

function handleDragOver(e) {
    if (e.preventDefault) e.preventDefault();
    e.dataTransfer.dropEffect = 'move';
    return false;
}

function handleDragEnter(e) {
    if (this === draggedElement) return;
    this.classList.add('drag-over');
}

function handleDragLeave(e) {
    if (this === draggedElement) return;
    this.classList.remove('drag-over');
}

function handleDrop(e) {
    if (e.stopPropagation) e.stopPropagation();
    this.classList.remove('drag-over');
    
    if (draggedElement && draggedElement !== this) {
        const grid = document.getElementById('dashboard-grid');
        const allModules = Array.from(grid.children).filter(el => el.classList.contains('dashboard-module'));
        const draggedIndex = allModules.indexOf(draggedElement);
        const targetIndex = allModules.indexOf(this);
        
        if (draggedIndex < targetIndex) {
            this.parentNode.insertBefore(draggedElement, this.nextSibling);
        } else {
            this.parentNode.insertBefore(draggedElement, this);
        }
        
        saveDashboardLayout();
    }
    return false;
}

function handleDragEnd(e) {
    this.classList.remove('dragging');
    this.dataset.dragHandleActive = 'false';
    
    // Remove visual feedback
    document.querySelectorAll('.dashboard-module').forEach(m => {
        m.style.opacity = '1';
        m.classList.remove('drag-over');
    });
}

function saveDashboardLayout() {
    const grid = document.getElementById('dashboard-grid');
    const layout = Array.from(grid.children).map(el => el.dataset.module).filter(m => m);
    localStorage.setItem('dashboardLayout_' + (__authHeader || 'default'), JSON.stringify(layout));
}

function loadDashboardLayout() {
    const savedLayout = localStorage.getItem('dashboardLayout_' + (__authHeader || 'default'));
    if (!savedLayout) return;
    
    try {
        const layout = JSON.parse(savedLayout);
        const grid = document.getElementById('dashboard-grid');
        if (!grid) return;
        
        layout.forEach(moduleId => {
            const module = grid.querySelector(`[data-module="${moduleId}"]`);
            if (module) grid.appendChild(module);
        });
    } catch (e) {
        console.error('Error loading dashboard layout:', e);
    }
}

function resetDashboardLayout() {
    if (confirm('Reset dashboard to default layout? This will reload the page and restore all settings.')) {
        localStorage.removeItem('dashboardLayout_' + (__authHeader || 'default'));
        localStorage.removeItem('hiddenModules_' + (__authHeader || 'default'));
        localStorage.removeItem('customWidget_' + (__authHeader || 'default'));
        location.reload();
    }
}

// Custom Widget Functions
// Custom Widget Functions - Multiple widgets support
let customWidgetCounter = 0;

function addCustomWidget() {
    const container = document.getElementById('custom-widgets-container');
    if (!container) return;
    
    customWidgetCounter++;
    const widgetId = 'custom-widget-' + customWidgetCounter;
    
    const widgetHtml = `
        <div class="dashboard-module" data-module="${widgetId}" draggable="true">
            <div class="card">
                <div class="card-header d-flex align-items-center">
                    <b>Custom Widget ${customWidgetCounter}</b>
                    <button class="btn btn-sm btn-outline-primary ms-2" onclick="editCustomWidget('${widgetId}')">
                        <i class="bi bi-pencil"></i> Edit
                    </button>
                    <span class="hide-toggle" onclick="removeCustomWidget('${widgetId}')" title="Remove widget"><i class="bi bi-trash"></i></span>
                    <span class="drag-handle ms-auto"><i class="bi bi-grip-vertical"></i></span>
                </div>
                <div class="card-body p-3 custom-widget-content" id="${widgetId}-content">
                    <p class="text-muted text-center mb-0">Click Edit to add custom content, embeds, or widgets</p>
                </div>
            </div>
        </div>
    `;
    
    container.insertAdjacentHTML('beforeend', widgetHtml);
    saveCustomWidgets();
    initDragAndDrop(); // Re-init drag for new widget
}

function editCustomWidget(widgetId) {
    const content = document.getElementById(widgetId + '-content');
    if (!content) return;
    
    const currentHtml = content.innerHTML;
    const newHtml = prompt('Enter custom HTML, embed code, or text:\n\n(Tip: You can use iframes, images, or any HTML)', currentHtml);
    
    if (newHtml !== null) {
        content.innerHTML = newHtml;
        saveCustomWidgets();
    }
}

function removeCustomWidget(widgetId) {
    if (!confirm('Remove this widget?')) return;
    const widget = document.querySelector(`[data-module="${widgetId}"]`);
    if (widget) {
        widget.remove();
        saveCustomWidgets();
    }
}

function saveCustomWidgets() {
    const container = document.getElementById('custom-widgets-container');
    if (!container) return;
    
    const widgets = [];
    container.querySelectorAll('.dashboard-module').forEach(widget => {
        const id = widget.dataset.module;
        const content = document.getElementById(id + '-content');
        if (content) {
            widgets.push({
                id: id,
                html: content.innerHTML
            });
        }
    });
    
    localStorage.setItem('customWidgets_' + (__authHeader || 'default'), JSON.stringify(widgets));
}

function loadCustomWidgets() {
    const saved = localStorage.getItem('customWidgets_' + (__authHeader || 'default'));
    if (!saved) return;
    
    try {
        const widgets = JSON.parse(saved);
        const container = document.getElementById('custom-widgets-container');
        if (!container) return;
        
        container.innerHTML = ''; // Clear existing
        
        widgets.forEach(widget => {
            const widgetNum = widget.id.replace('custom-widget-', '');
            customWidgetCounter = Math.max(customWidgetCounter, parseInt(widgetNum) || 0);
            
            const widgetHtml = `
                <div class="dashboard-module" data-module="${widget.id}" draggable="true">
                    <div class="card">
                        <div class="card-header d-flex align-items-center">
                            <b>Custom Widget ${widgetNum}</b>
                            <button class="btn btn-sm btn-outline-primary ms-2" onclick="editCustomWidget('${widget.id}')">
                                <i class="bi bi-pencil"></i> Edit
                            </button>
                            <span class="hide-toggle" onclick="removeCustomWidget('${widget.id}')" title="Remove widget"><i class="bi bi-trash"></i></span>
                            <span class="drag-handle ms-auto"><i class="bi bi-grip-vertical"></i></span>
                        </div>
                        <div class="card-body p-3 custom-widget-content" id="${widget.id}-content">
                            ${widget.html}
                        </div>
                    </div>
                </div>
            `;
            container.insertAdjacentHTML('beforeend', widgetHtml);
        });
        
        initDragAndDrop(); // Re-init drag for loaded widgets
    } catch (e) {
        console.error('Error loading custom widgets:', e);
    }
}
// Resizable Table Columns
function makeTableResizable(table) {
    if (!table || table.classList.contains('resizable-init')) return;
    table.classList.add('resizable-table', 'resizable-init');
    
    const thead = table.querySelector('thead');
    if (!thead) return;
    
    const headers = thead.querySelectorAll('th');
    headers.forEach((th, index) => {
        // Skip last column
        if (index === headers.length - 1) return;
        
        const handle = document.createElement('div');
        handle.className = 'resize-handle';
        th.style.position = 'relative';
        th.appendChild(handle);
        
        let startX, startWidth, targetTh;
        
        handle.addEventListener('mousedown', function(e) {
            e.preventDefault();
            targetTh = this.parentElement;
            startX = e.pageX;
            startWidth = targetTh.offsetWidth;
            
            handle.classList.add('active');
            document.body.style.cursor = 'col-resize';
            document.body.style.userSelect = 'none';
            
            document.addEventListener('mousemove', onMouseMove);
            document.addEventListener('mouseup', onMouseUp);
        });
        
        function onMouseMove(e) {
            if (!targetTh) return;
            const diff = e.pageX - startX;
            const newWidth = Math.max(50, startWidth + diff);
            targetTh.style.width = newWidth + 'px';
            targetTh.style.minWidth = newWidth + 'px';
        }
        
        function onMouseUp() {
            handle.classList.remove('active');
            document.body.style.cursor = '';
            document.body.style.userSelect = '';
            document.removeEventListener('mousemove', onMouseMove);
            document.removeEventListener('mouseup', onMouseUp);
            targetTh = null;
        }
    });
}

// Make all tables resizable
function initResizableTables() {
    document.querySelectorAll('.dashboard-module table, .config-module table').forEach(table => {
        makeTableResizable(table);
    });
}

// Sync sidebar buttons with main buttons
function syncAuthButtons() {
    const loginBtn = document.getElementById('login-btn');
    const logoutBtn = document.getElementById('logout-btn');
    const configLink = document.getElementById('config-link');
    
    const loginBtnSidebar = document.getElementById('login-btn-sidebar');
    const logoutBtnSidebar = document.getElementById('logout-btn-sidebar');
    const configLinkSidebar = document.getElementById('config-link-sidebar');
    
    if (loginBtn && loginBtnSidebar) {
        if (loginBtn.classList.contains('d-none')) {
            loginBtnSidebar.classList.add('d-none');
        } else {
            loginBtnSidebar.classList.remove('d-none');
        }
    }
    
    if (logoutBtn && logoutBtnSidebar) {
        if (logoutBtn.classList.contains('d-none')) {
            logoutBtnSidebar.classList.add('d-none');
        } else {
            logoutBtnSidebar.classList.remove('d-none');
        }
    }
    
    if (configLink && configLinkSidebar) {
        if (configLink.classList.contains('d-none')) {
            configLinkSidebar.classList.add('d-none');
        } else {
            configLinkSidebar.classList.remove('d-none');
        }
    }
    
    // Ensure sidebar button onclicks are wired even if DOM updated
    if (loginBtnSidebar) loginBtnSidebar.onclick = promptLogin;
    if (logoutBtnSidebar) logoutBtnSidebar.onclick = logout;
}
    syncAuthButtons();

// Hide/Show Module Functions
function toggleHideModule(moduleId) {
    const module = document.querySelector(`[data-module="${moduleId}"]`);
    if (!module) return;
    
    module.classList.add('hidden');
    saveHiddenModules();
    updateShowHiddenButton();
}

function saveHiddenModules() {
    const hiddenModules = Array.from(document.querySelectorAll('.dashboard-module.hidden'))
        .map(el => el.dataset.module)
        .filter(m => m);
    localStorage.setItem('hiddenModules_' + (__authHeader || 'default'), JSON.stringify(hiddenModules));
}

function loadHiddenModules() {
    const saved = localStorage.getItem('hiddenModules_' + (__authHeader || 'default'));
    if (!saved) return;
    
    try {
        const hiddenModules = JSON.parse(saved);
        hiddenModules.forEach(moduleId => {
            const module = document.querySelector(`[data-module="${moduleId}"]`);
            if (module) module.classList.add('hidden');
        });
        updateShowHiddenButton();
    } catch (e) {
        console.error('Error loading hidden modules:', e);
    }
}

function showHiddenModules() {
    const hiddenModules = document.querySelectorAll('.dashboard-module.hidden');
    if (hiddenModules.length === 0) {
        alert('No hidden modules to show.');
        return;
    }
    
    const moduleNames = Array.from(hiddenModules).map(el => {
        const title = el.querySelector('.card-header b');
        return title ? title.textContent : el.dataset.module;
    });
    
    const message = `Hidden modules:\n\n${moduleNames.map((n, i) => `${i + 1}. ${n}`).join('\n')}\n\nShow all hidden modules?`;
    
    if (confirm(message)) {
        hiddenModules.forEach(module => module.classList.remove('hidden'));
        saveHiddenModules();
        updateShowHiddenButton();
    }
}

function updateShowHiddenButton() {
    const btn = document.getElementById('show-hidden-btn');
    if (!btn) return;
    
    const hiddenCount = document.querySelectorAll('.dashboard-module.hidden').length;
    if (hiddenCount > 0) {
        btn.classList.remove('d-none');
        btn.innerHTML = `<i class="bi bi-eye"></i> Show Hidden (${hiddenCount})`;
    } else {
        btn.classList.add('d-none');
    }
}

// Public IP obfuscation
let __publicIP = '•••.•••.•••.•••';
let __publicIPRevealed = false;

// Public IP Extraction from IPChicken
function extractPublicIP() {
    try {
        const iframe = document.getElementById('ipchicken-frame');
        const iframeDoc = iframe.contentDocument || iframe.contentWindow.document;
        const bodyText = iframeDoc.body.innerText || iframeDoc.body.textContent;
        
        // IPChicken displays IP in format like "Current IP Address: X.X.X.X"
        const ipMatch = bodyText.match(/\b(?:\d{1,3}\.){3}\d{1,3}\b/);
        
        if (ipMatch) {
            __publicIP = ipMatch[0];
        } else {
            __publicIP = 'Unable to detect';
        }
    } catch (e) {
        // CORS issue - fallback to API
        fetch('https://api.ipify.org?format=json')
            .then(response => response.json())
            .then(data => {
                __publicIP = data.ip;
            })
            .catch(() => {
                __publicIP = 'Unavailable';
            });
    }
}

function revealPublicIP() {
    if (!__publicIPRevealed && __publicIP) {
        document.getElementById('public-ip-display').textContent = __publicIP;
        __publicIPRevealed = true;
    }
}

function hidePublicIP() {
    if (__publicIPRevealed) {
        document.getElementById('public-ip-display').textContent = '•••.•••.•••.•••';
        __publicIPRevealed = false;
    }
}

function copyPublicIP(el) {
    if (__publicIP && __publicIP !== '•••.•••.•••.•••') {
        copyToClipboard(__publicIP, el);
    } else {
        showNotification('Public IP not yet loaded', 'warning');
    }
}
// Export public IP helpers to global for inline handlers and iframe load
window.extractPublicIP = extractPublicIP;
window.revealPublicIP = revealPublicIP;
window.hidePublicIP = hidePublicIP;
window.copyPublicIP = copyPublicIP;

// Ensure these functions are globally accessible for inline event handlers
window.revealPublicIP = revealPublicIP;
window.hidePublicIP = hidePublicIP;
window.copyPublicIP = copyPublicIP;

// Generic copy to clipboard with visual feedback
function copyToClipboard(text, el) {
    navigator.clipboard.writeText(text).then(() => {
        const original = el.textContent;
        el.textContent = '✓ Copied!';
        el.style.color = '#28a745';
        setTimeout(() => {
            el.textContent = original;
            el.style.color = '';
        }, 1500);
        showNotification('Copied to clipboard', 'success');
    }).catch(() => {
        showNotification('Failed to copy', 'danger');
    });
}
window.copyToClipboard = copyToClipboard;

// Dev Reset to Setup
function devResetToSetup() {
    if (!confirm('⚠️ WARNING: This will DELETE all config, users, passwords, and state files.\n\nThis will force the setup wizard on next page load.\n\nAre you sure?')) {
        return;
    }
    fetch('/dev/reset-to-setup', { method: 'POST' })
        .then(r => r.json())
        .then(data => {
            if (data.success) {
                showNotification('Reset complete! Reloading...', 'success');
                setTimeout(() => { window.location.href = '/'; }, 1500);
            } else {
                showNotification('Reset failed: ' + (data.error || 'Unknown error'), 'danger');
            }
        })
        .catch(err => {
            showNotification('Error: ' + err.message, 'danger');
        });
}

// --- Column width preferences for Custom Routes and Tag Routes ---
function setColWidth(prefix, col, pct) {
    const el = document.getElementById(`${prefix}-${col}-col`);
    if (el) el.style.width = `${pct}%`;
}

function applyColumnPrefs(prefix, cols) {
    cols.forEach(col => {
        const key = `dor_${prefix}_${col}_width_pct`;
        const val = localStorage.getItem(key);
        if (val) {
            const pct = parseInt(val, 10);
            setColWidth(prefix, col, pct);
            // Also update slider if present
            const slider = document.getElementById(`${prefix}-${col}-width`);
            if (slider) slider.value = pct;
        }
    });
}

function hookColumnSliders(prefix, cols) {
    cols.forEach(col => {
        const slider = document.getElementById(`${prefix}-${col}-width`);
        if (!slider) return;
        slider.addEventListener('input', (e) => {
            const pct = parseInt(e.target.value, 10);
            setColWidth(prefix, col, pct);
        });
    });
}

function saveCustomRoutesColumnPrefs() {
    saveColumnPrefs('cr', ['ext','folder','action']);
}

function saveTagRoutesColumnPrefs() {
    saveColumnPrefs('tr', ['tag','folder','action']);
}

// Load organizer config and apply feature gating
async function loadOrganizerConfig() {
    try {
        const resp = await fetch('/api/organizer/config', {
            credentials: 'include',
            cache: 'no-store',
            headers: getAuthHeaders()
        });
        if (!resp.ok) return;
        const cfg = await resp.json();
        const features = cfg.features || {};
        __organizerFeatures = {
            virustotal_enabled: features.virustotal_enabled !== false,
            duplicates_enabled: features.duplicates_enabled !== false,
            reports_enabled: features.reports_enabled !== false
        };
        __vtApiKey = cfg.vt_api_key || cfg.virustotal_api_key || '';
        applyFeatureGating();
    } catch (e) {
        console.warn('Failed to load organizer config:', e);
    }
}

function applyFeatureGating() {
    // Duplicates gating
    const dupBanner = document.getElementById('duplicates-disabled-banner');
    const dupBody = document.getElementById('duplicates-body');
    if (dupBanner && dupBody) {
        if (!__organizerFeatures.duplicates_enabled) {
            dupBanner.classList.remove('d-none');
            dupBody.style.display = 'none';
            const b = document.getElementById('badge-duplicates-state');
            if (b) { b.textContent = 'Off'; b.className = 'badge bg-secondary ms-2'; }
        } else {
            dupBanner.classList.add('d-none');
            dupBody.style.display = '';
            const b = document.getElementById('badge-duplicates-state');
            if (b) { b.textContent = 'On'; b.className = 'badge bg-success ms-2'; }
        }
    }
    // Reports/statistics gating
    const repBanner = document.getElementById('reports-disabled-banner');
    const statsBody = document.getElementById('statistics-body');
    if (repBanner && statsBody) {
        if (!__organizerFeatures.reports_enabled) {
            repBanner.classList.remove('d-none');
            statsBody.style.display = 'none';
            const b = document.getElementById('badge-reports-state');
            if (b) { b.textContent = 'Off'; b.className = 'badge bg-secondary ms-2'; }
        } else {
            repBanner.classList.add('d-none');
            statsBody.style.display = '';
            const b = document.getElementById('badge-reports-state');
            if (b) { b.textContent = 'On'; b.className = 'badge bg-success ms-2'; }
        }
    }
    // Virustotal gating in recent files (button visibility)
    const vtButtons = document.querySelectorAll('[data-action="vt-scan"]');
    vtButtons.forEach(btn => {
        const enabled = __organizerFeatures.virustotal_enabled && !!__vtApiKey;
        btn.style.display = enabled ? '' : 'none';
        if (!enabled) btn.title = 'VirusTotal disabled or API key missing';
    });
}

function applyRights() {
    document.querySelectorAll('[data-right]').forEach(el => {
        const need = el.getAttribute('data-right');
        if (!__rights[need]) {
            // Graceful message instead of hiding
            const collapses = el.querySelectorAll('.collapse');
            collapses.forEach(c => {
                c.innerHTML = `<div class="ps-2 pe-2 pt-2 pb-1"><small class="text-muted">You lack rights (<code>${need}</code>) to view this section.</small></div>`;
            });
        }
    });
    // Service buttons gating
    if (!__rights.manage_service) {
        document.querySelectorAll('#collapseServiceStatus button').forEach(b => {
            b.disabled = true;
            b.title = 'Insufficient rights (manage_service)';
        });
    }
    async function pollRights() {
        if (!__authHeader) return; // only when logged in
        try {
            const resp = await fetch('/auth/session', { headers: getAuthHeaders(), credentials: 'include' });
            if (!resp.ok) return;
            const data = await resp.json();
            const newVersion = data.config_version || 0;
            if (newVersion !== __configVersion) {
                __configVersion = newVersion;
                __rights = data.rights || {};
                applyRights();
                if (__rights.view_metrics) updateServiceStatus();
                if (__rights.view_recent_files) refreshRecentFiles();
            }
        } catch (e) {
            // Silent failures acceptable
        }
    }
    // Config save gating
    if (!__rights.manage_config) {
        const cfgBtn = document.querySelector('#config-form button.btn-primary');
        if (cfgBtn) {
            cfgBtn.disabled = true;
            cfgBtn.title = 'Insufficient rights (manage_config)';
        }
        const setBtn = document.querySelector('#config-form-settings button.btn-primary');
        if (setBtn) {
            setBtn.disabled = true;
            setBtn.title = 'Insufficient rights (manage_config)';
        }
    }
    // Call page-specific rights application if available (e.g., for config page)
    if (typeof applyConfigRights === 'function') {
        applyConfigRights();
    }
}

// Service Control Functions
async function startService() {
    await serviceAction('start');
}

async function stopService() {
    await serviceAction('stop');
}

async function restartService() {
    await serviceAction('restart');
}

async function serviceAction(action) {
    try {
        if (!__authHeader) {
            showNotification('Please login before performing service actions', 'warning');
            return;
        }
        const response = await fetch(`/${action}`, {
            method: 'POST',
            credentials: 'include',
            headers: getAuthHeaders()
        });
        const data = await response.json();
        if (response.ok) {
            showNotification(`Service ${action}ed successfully`, 'success');
            setTimeout(updateServiceStatus, 1000);
        } else {
            showNotification(data.message || `Failed to ${action} service`, 'danger');
        }
    } catch (error) {
        showNotification(`Error: ${error.message}`, 'danger');
    }
}

// Update service status
async function updateServiceStatus() {
    try {
        const response = await fetch('/metrics');
        const data = await response.json();
        
        // Update both main and sidebar badges
        const badge = document.getElementById('service-badge');
        const badgeSidebar = document.getElementById('service-badge-sidebar');
        const statusClass = data.service_status === 'Running' ? 'bg-success' : 'bg-danger';
        
        if (badge) {
            badge.textContent = data.service_status;
            badge.className = `badge ${statusClass} ms-1`;
        }
        
        if (badgeSidebar) {
            badgeSidebar.textContent = data.service_status;
            badgeSidebar.className = `badge ${statusClass} ms-1`;
            badgeSidebar.style.fontSize = '0.7rem';
        }
    } catch (error) {
        console.error('Error updating service status:', error);
    }
}

// Fetch configured service name from server and display in header
async function fetchServiceName() {
    try {
        const resp = await fetch('/service_name');
        if (!resp.ok) return;
        const data = await resp.json();
        const name = data.service_name || '';
        const el = document.getElementById('service-name');
        const btn = document.getElementById('service-name-btn');
        if (el) el.textContent = name;
        if (btn) btn.style.display = name ? 'inline-block' : 'none';
    } catch (err) {
        console.error('Failed to fetch service name:', err);
    }
}

function copyServiceName() {
    const el = document.getElementById('service-name');
    if (!el) return;
    const name = el.textContent || '';
    if (!name) return;
    navigator.clipboard?.writeText(name).then(() => {
        showNotification('Service name copied to clipboard', 'success');
    }).catch(() => {
        showNotification('Failed to copy service name', 'warning');
    });
}

// Configuration Save
async function saveConfiguration() {
    const catForm = document.getElementById('config-form');
    const customForm = document.getElementById('custom-routes-form');
    const catData = new FormData(catForm);
    const customData = new FormData(customForm);
    
    // Build routes dict from category form
    const routes = {};
    let i = 1;
    let foundAny = true;
    while (foundAny) {
        const folder = catData.get(`folder_${i}`);
        const exts = catData.get(`exts_${i}`);
        if (folder !== null && exts !== null) {
            const list = (exts || '').split(',').map(s => s.trim()).filter(Boolean);
            if (folder.trim()) routes[folder.trim()] = list;
            i++;
        } else {
            foundAny = false;
        }
    }

    // Build custom_routes dict from custom form
    const custom_routes = {};
    if (customForm) {
        let j = 1;
        let foundAny = true;
        while (foundAny) {
            const ext = customData.get(`ext_${j}`);
            const path = customData.get(`path_${j}`);
            if (ext !== null || path !== null) {
                if (ext && path && ext.trim() && path.trim()) {
                    custom_routes[ext.trim()] = path.trim();
                }
                j++;
            } else {
                foundAny = false;
            }
        }
    }

    // Build tag_routes dict from tag form
    const tagForm = document.getElementById('tag-routes-form');
    const tag_routes = {};
    if (tagForm) {
        const tagData = new FormData(tagForm);
        let k = 1;
        let foundAny = true;
        while (foundAny) {
            const tag = tagData.get(`tag_${k}`);
            const tagpath = tagData.get(`tagpath_${k}`);
            if (tag !== null || tagpath !== null) {
                if (tag && tagpath && tag.trim() && tagpath.trim()) {
                    tag_routes[tag.trim()] = tagpath.trim();
                }
                k++;
            } else {
                foundAny = false;
            }
        }
    }

    // Prepare JSON payload
    const payload = {
        routes,
        custom_routes,
        tag_routes
    };
    
    try {
        if (!__authHeader) {
            showNotification('Please login before saving configuration', 'warning');
            return;
        }
        const response = await fetch('/api/update', {
            method: 'POST',
            body: JSON.stringify(payload),
            credentials: 'include',
            headers: { ...getAuthHeaders(), 'Content-Type': 'application/json' }
        });
        if (response.ok) {
            const result = await response.json();
            showNotification(result.message || 'Configuration saved successfully', 'success');
            // Reload the configuration to show the saved data
            await initializeCustomRoutes();
            
            // Ask if user wants to restart the service to apply changes
            if (confirm('Configuration saved! Would you like to restart the Organizer service now to apply the changes?')) {
                try {
                    const restartResponse = await fetch('/restart', {
                        method: 'POST',
                        credentials: 'include',
                        headers: getAuthHeaders()
                    });
                    if (restartResponse.ok) {
                        showNotification('Service restarted successfully. File organization will resume momentarily.', 'success');
                    } else {
                        showNotification('Failed to restart service. Please restart manually.', 'warning');
                    }
                } catch (err) {
                    showNotification('Error restarting service: ' + err.message, 'warning');
                }
            } else {
                showNotification('Remember to restart the service manually for changes to take effect.', 'info');
            }
        } else {
            const t = await response.text();
            showNotification('Failed to save configuration: ' + t.substring(0,200), 'danger');
        }
    } catch (error) {
        showNotification(`Error: ${error.message}`, 'danger');
    }
}

async function saveSettings() {
    const form = document.getElementById('config-form-settings');
    const formData = new FormData(form);
    
    try {
        if (!__authHeader) {
            showNotification('Please login before saving settings', 'warning');
            return;
        }
        const response = await fetch('/api/update', {
            method: 'POST',
            body: formData,
            credentials: 'include',
            headers: getAuthHeaders()
        });
        if (response.ok) {
            const result = await response.json();
            showNotification(result.message || 'Settings saved successfully', 'success');
            
            // Check if watch_folder was changed
            const watchFolder = formData.get('watch_folder');
            if (watchFolder) {
                // Ask if user wants to restart the service to apply watch folder change
                if (confirm('Watch folder setting saved! Would you like to restart the Organizer service now to apply the changes?')) {
                    try {
                        const restartResponse = await fetch('/restart', {
                            method: 'POST',
                            credentials: 'include',
                            headers: getAuthHeaders()
                        });
                        if (restartResponse.ok) {
                            showNotification('Service restarted successfully. Now monitoring: ' + watchFolder, 'success');
                        } else {
                            showNotification('Failed to restart service. Please restart manually.', 'warning');
                        }
                    } catch (err) {
                        showNotification('Error restarting service: ' + err.message, 'warning');
                    }
                } else {
                    showNotification('Remember to restart the service manually for watch folder changes to take effect.', 'info');
                }
            }
        } else {
            showNotification('Failed to save settings', 'danger');
        }
    } catch (error) {
        showNotification(`Error: ${error.message}`, 'danger');
    }
}

function deleteRow(btn) {
    btn.closest('tr').remove();
}

// Add new category row to File Categories table
function addCategoryRow() {
    const tbody = document.querySelector('#config-form tbody');
    const rowCount = tbody.querySelectorAll('tr').length + 1;
    const newRow = document.createElement('tr');
    newRow.innerHTML = `
        <td><input class="form-control form-control-sm" type="text" name="folder_${rowCount}" placeholder="Folder name"></td>
        <td><input class="form-control form-control-sm" type="text" name="exts_${rowCount}" placeholder="ext1, ext2, ext3"></td>
        <td><button class="btn btn-danger btn-sm" type="button" onclick="deleteRow(this)">Delete</button></td>
    `;
    tbody.appendChild(newRow);
}

// Add new custom route row to Custom Routes table
function addCustomRouteRow() {
    const tbody = document.getElementById('custom-routes-tbody');
    const rowCount = tbody.querySelectorAll('tr').length + 1;
    const newRow = document.createElement('tr');
    newRow.innerHTML = `
        <td><input class="form-control form-control-sm" type="text" name="ext_${rowCount}" placeholder="mp4"></td>
        <td><input class="form-control form-control-sm" type="text" name="path_${rowCount}" placeholder="C:/Media/Videos"></td>
        <td><button class="btn btn-danger btn-sm" type="button" onclick="deleteRow(this)">Delete</button></td>
    `;
    tbody.appendChild(newRow);
}

// Add new tag route row to Tag Routes table
function addTagRouteRow() {
    const tbody = document.getElementById('tag-routes-tbody');
    const rowCount = tbody.querySelectorAll('tr').length + 1;
    const newRow = document.createElement('tr');
    newRow.innerHTML = `
        <td><input class="form-control form-control-sm" type="text" name="tag_${rowCount}" placeholder="invoice"></td>
        <td><input class="form-control form-control-sm" type="text" name="tagpath_${rowCount}" placeholder="C:/Documents/Invoices"></td>
        <td><button class="btn btn-danger btn-sm" type="button" onclick="deleteRow(this)">Delete</button></td>
    `;
    tbody.appendChild(newRow);
}

// Load custom routes from config on page load
function loadCustomRoutes(customRoutes) {
    const tbody = document.getElementById('custom-routes-tbody');
    if (!tbody) return; // Not on dashboard page
    
    tbody.innerHTML = ''; // Clear existing rows
    
    if (customRoutes && Object.keys(customRoutes).length > 0) {
        let index = 1;
        for (const [ext, path] of Object.entries(customRoutes)) {
            const row = document.createElement('tr');
            row.innerHTML = `
                <td><input class="form-control form-control-sm" type="text" name="ext_${index}" value="${ext}"></td>
                <td><input class="form-control form-control-sm" type="text" name="path_${index}" value="${path}"></td>
                <td><button class="btn btn-danger btn-sm" type="button" onclick="deleteRow(this)">Delete</button></td>
            `;
            tbody.appendChild(row);
            index++;
        }
    }
}

// Initialize custom routes table on page load
async function loadFileCategories(routes) {
    const tbody = document.querySelector('#config-form tbody');
    if (!tbody) return;
    
    // Clear existing rows
    tbody.innerHTML = '';
    
    // Populate rows from config
    let rowNum = 1;
    for (const [folder, extensions] of Object.entries(routes)) {
        const row = document.createElement('tr');
        row.innerHTML = `
            <td><input class="form-control form-control-sm" type="text" name="folder_${rowNum}" value="${folder}"></td>
            <td><input class="form-control form-control-sm" type="text" name="exts_${rowNum}" value="${extensions.join(', ')}"></td>
            <td><button class="btn btn-danger btn-sm" type="button" onclick="deleteRow(this)">Delete</button></td>
        `;
        tbody.appendChild(row);
        rowNum++;
    }
}

async function initializeCustomRoutes() {
    try {
        const response = await fetch('/api/organizer/config', {
            credentials: 'include',
            headers: getAuthHeaders()
        });
        
        if (response.ok) {
            const config = await response.json();
            
            // Load file categories
            if (config.routes && Object.keys(config.routes).length > 0) {
                loadFileCategories(config.routes);
            }
            
            // Load custom routes
            if (config.custom_routes && Object.keys(config.custom_routes).length > 0) {
                loadCustomRoutes(config.custom_routes);
            }
            
            // Load tag routes
            if (config.tag_routes && Object.keys(config.tag_routes).length > 0) {
                loadTagRoutes(config.tag_routes);
            }
        }
    } catch (error) {
        console.log('Could not load configuration:', error);
    }
}

// Load tag routes from config on page load
function loadTagRoutes(tagRoutes) {
    const tbody = document.getElementById('tag-routes-tbody');
    if (!tbody) return; // Not on dashboard page
    
    tbody.innerHTML = ''; // Clear existing rows
    
    if (tagRoutes && Object.keys(tagRoutes).length > 0) {
        let index = 1;
        for (const [tag, path] of Object.entries(tagRoutes)) {
            const row = document.createElement('tr');
            row.innerHTML = `
                <td><input class="form-control form-control-sm" type="text" name="tag_${index}" value="${tag}"></td>
                <td><input class="form-control form-control-sm" type="text" name="tagpath_${index}" value="${path}"></td>
                <td><button class="btn btn-danger btn-sm" type="button" onclick="deleteRow(this)">Delete</button></td>
            `;
            tbody.appendChild(row);
            index++;
        }
    }
}

// Log streaming
function streamLog(which) {
    const logElement = document.getElementById(`${which}-log`);
    const eventSource = new EventSource(`/stream/${which}`);
    eventSource.onmessage = function(event) {
        if (event.data) {
            logElement.textContent += event.data + '\n';
            logElement.scrollTop = logElement.scrollHeight;
        }
    };
    eventSource.onerror = function() {
        eventSource.close();
        setTimeout(() => streamLog(which), 5000);
    };
}

// Clear log
async function clearLog(which) {
    try {
        const response = await fetch(`/clear_log/${which}`, {
            method: 'POST',
            credentials: 'include',
            headers: getAuthHeaders()
        });
        if (response.ok) {
            const logElement = document.getElementById(`${which}-log`);
            logElement.textContent = '';
            showNotification(`${which.toUpperCase()} log cleared`, 'success');
        } else {
            showNotification(`Failed to clear ${which} log`, 'danger');
        }
    } catch (error) {
        showNotification(`Error: ${error.message}`, 'danger');
    }
}

// Show notification in fixed container
function showNotification(message, type) {
    const alertDiv = document.createElement('div');
    alertDiv.className = `alert alert-${type} alert-dismissible fade show`;
    alertDiv.innerHTML = `
        ${message}
        <button type="button" class="btn-close" data-bs-dismiss="alert"></button>
    `;
    
    const container = document.getElementById('notification-container');
    if (container) {
        container.appendChild(alertDiv);
    } else {
        // Fallback for pages without notification container
        const mainContainer = document.querySelector('.container');
        mainContainer.insertBefore(alertDiv, mainContainer.firstChild);
    }
    
    setTimeout(() => {
        alertDiv.remove();
    }, 5000);
}

// Recent Files Functions
async function refreshRecentFiles() {
    const btn = document.getElementById('btn-recent-refresh');
    const tbody = document.getElementById('recent-files-tbody');
    const originalHtml = btn ? btn.innerHTML : '';
    
    try {
        if (btn) {
            btn.disabled = true;
            btn.innerHTML = '<span class="spinner-border spinner-border-sm me-1"></span>Loading...';
        }
        
        const response = await fetch('/api/recent_files', {
            credentials: 'include',
            headers: getAuthHeaders()
        });
        
        if (!response.ok) {
            throw new Error('Failed to fetch recent files');
        }
        
        const files = await response.json();
        displayRecentFiles(files);
    } catch (error) {
        console.error('Error fetching recent files:', error);
        if (tbody) {
            tbody.innerHTML = '<tr><td colspan="5" class="text-center text-danger">Error loading recent files</td></tr>';
        }
        showNotification('Failed to refresh recent files: ' + error.message, 'danger');
    } finally {
        if (btn) {
            btn.disabled = false;
            btn.innerHTML = originalHtml || '<i class="bi bi-arrow-clockwise"></i> Refresh';
        }
    }
}

function displayRecentFiles(files) {
    const tbody = document.getElementById('recent-files-tbody');
    
    if (!files || files.length === 0) {
        tbody.innerHTML = '<tr><td colspan="5" class="text-center text-muted">No recent file movements</td></tr>';
        return;
    }
    
    tbody.innerHTML = files.map(file => {
        const timestamp = new Date(file.timestamp);
        const timeStr = timestamp.toLocaleString();
        const categoryBadge = getCategoryBadge(file.category);
        
        const fileIndex = files.indexOf(file);
        return `
            <tr>
                <td><small>${timeStr}</small></td>
                <td>
                    <small><strong>${escapeHtml(file.filename)}</strong></small>
                    <br><small class="text-muted">${escapeHtml(file.destination_path)}</small>
                </td>
                <td>${categoryBadge}</td>
                <td>
                    <button class="btn btn-sm btn-outline-primary" onclick='openFile(${JSON.stringify(file.destination_path)}, "open")' title="Open file">
                        <i class="bi bi-folder2-open"></i> Open
                    </button>
                    <button class="btn btn-sm btn-outline-secondary" onclick='openFile(${JSON.stringify(file.destination_path)}, "reveal")' title="Show in folder">
                        <i class="bi bi-folder"></i> Show
                    </button>
                    ${(__organizerFeatures.virustotal_enabled && __vtApiKey) ? `<button class="btn btn-sm btn-outline-info" onclick='scanVirusTotal(${JSON.stringify(file.destination_path)}, ${JSON.stringify(file.filename)})' title="Scan with VirusTotal"><i class="bi bi-shield-check"></i> VT</button>` : ''}
                </td>
                <td>
                    <button class="btn btn-sm btn-outline-danger" onclick='removeRecentFile(${fileIndex})' title="Remove from recent">
                        <i class="bi bi-x-lg"></i>
                    </button>
                </td>
            </tr>
        `;
    }).join('');
}

function getCategoryBadge(category) {
    const badges = {
        'Images': 'bg-success',
        'Videos': 'bg-primary',
        'Music': 'bg-info',
        'Documents': 'bg-warning',
        'Archives': 'bg-secondary',
        'Executables': 'bg-danger',
        'Scripts': 'bg-dark',
        'Fonts': 'bg-light text-dark',
        'Shortcuts': 'bg-info',
        'Logs': 'bg-secondary',
        'Other': 'bg-secondary'
    };
    const badgeClass = badges[category] || 'bg-secondary';
    return `<span class="badge ${badgeClass}">${escapeHtml(category)}</span>`;
}

async function openFile(filePath, action = 'open') {
    try {
        const response = await fetch('/api/open_file', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                ...getAuthHeaders()
            },
            credentials: 'include',
            body: JSON.stringify({
                file_path: filePath,
                action: action
            })
        });
        
        const data = await response.json();
        
        if (response.ok) {
            showNotification(data.message || `File ${action === 'reveal' ? 'revealed' : 'opened'}`, 'success');
        } else {
            showNotification(data.error || 'Failed to open file', 'danger');
        }
    } catch (error) {
        showNotification(`Error: ${error.message}`, 'danger');
    }
}

function escapeHtml(text) {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
}

async function removeRecentFile(index) {
    if (!confirm('Remove this file from recent files list?')) {
        return;
    }
    
    try {
        const response = await fetch(`/api/recent_files/${index}`, {
            method: 'DELETE',
            credentials: 'include',
            headers: getAuthHeaders()
        });
        
        if (response.ok) {
            showNotification('File removed from recent files', 'success');
            refreshRecentFiles();
        } else {
            const data = await response.json();
            showNotification(data.error || 'Failed to remove file', 'danger');
        }
    } catch (error) {
        showNotification(`Error: ${error.message}`, 'danger');
    }
}

// Initialize on page load
document.addEventListener('DOMContentLoaded', function() {
    loadCustomWidgets();
    loadDashboardLayout();
    initDragAndDrop();
    loadHiddenModules();
    initResizableTables();
    syncAuthButtons();
    initSidebarResizer();

    // Cookie-based auth persistence helpers
    function setCookie(name, value, days) {
        const d = new Date();
        d.setTime(d.getTime() + (days*24*60*60*1000));
        const expires = 'expires=' + d.toUTCString();
        const secure = location.protocol === 'https:' ? '; Secure' : '';
        document.cookie = name + '=' + encodeURIComponent(value) + '; ' + expires + '; Path=/' + '; SameSite=Lax' + secure;
    }
    function getCookie(name) {
        const decoded = decodeURIComponent(document.cookie || '');
        const ca = decoded.split(';');
        name = name + '=';
        for (let c of ca) {
            while (c.charAt(0) === ' ') c = c.substring(1);
            if (c.indexOf(name) === 0) return c.substring(name.length, c.length);
        }
        return null;
    }
    function deleteCookie(name) {
        const secure = location.protocol === 'https:' ? '; Secure' : '';
        document.cookie = name + '=; expires=Thu, 01 Jan 1970 00:00:00 GMT; Path=/; SameSite=Lax' + secure;
    }

    // Restore auth from sessionStorage or cookie if available
    try {
        let storedAuth = sessionStorage.getItem('authHeader');
        if (!storedAuth) {
            storedAuth = getCookie('authHeader');
        }
        if (storedAuth) {
            __authHeader = storedAuth;
            // Verify stored auth is still valid
            fetch('/auth_check', {
                credentials: 'include',
                headers: { 'Authorization': __authHeader }
            }).then(response => {
                if (response.ok) {
                    return response.json();
                } else {
                    __authHeader = null;
                    sessionStorage.removeItem('authHeader');
                    deleteCookie('authHeader');
                    throw new Error('Stored auth invalid');
                }
            }).then(data => {
                __rights = data.rights || {};
                __configVersion = data.config_version || 0;
                document.getElementById('login-btn').classList.add('d-none');
                document.getElementById('logout-btn').classList.remove('d-none');
                if (__rights.manage_config || __rights.modify_layout) {
                    document.getElementById('config-link').classList.remove('d-none');
                }
                applyRights();
                if (__rights.view_recent_files) refreshRecentFiles();
                if (__rights.view_metrics) {
                    updateServiceStatus();
                    streamLog('stdout');
                    streamLog('stderr');
                }
                // Initialize custom routes table if present
                initializeCustomRoutes();
            }).catch(err => {
                console.log('Auth restoration failed:', err);
            });
        }
    } catch (e) {
        console.warn('sessionStorage not available:', e);
    }
    
    // Initialize custom routes table on dashboard load
    initializeCustomRoutes();
    
    // Intercept config link clicks to use fetch with auth header
    const configLink = document.getElementById('config-link');
    if (configLink) {
        configLink.addEventListener('click', function(e) {
            e.preventDefault();
            if (!__authHeader) {
                showNotification('Please login first', 'warning');
                return;
            }
            // Navigate with auth by fetching and loading the page
            fetch('/config', {
                credentials: 'include',
                headers: { 'Authorization': __authHeader }
            }).then(response => {
                if (response.ok) {
                    return response.text();
                } else if (response.status === 401) {
                    showNotification('Authentication required', 'danger');
                    throw new Error('Unauthorized');
                } else {
                    throw new Error('Failed to load config page');
                }
            }).then(html => {
                // Replace page content with fetched HTML
                document.open();
                document.write(html);
                document.close();
            }).catch(err => {
                console.error('Config page load failed:', err);
                showNotification('Failed to load config page: ' + err.message, 'danger');
            });
        });
    }
    
    fetchServiceName();
    // Fetch CSRF token
    fetchCSRFToken();
    // Start polling rights periodically
    setInterval(pollRights, __rightsPollIntervalMs);
    // Load dashboard data with feature gating
    if (__organizerFeatures.reports_enabled) {
        loadStatistics();
    } else {
        const el = document.getElementById('chart-category');
        if (el) {
            const parent = el.closest('.card-body');
            if (parent) parent.insertAdjacentHTML('afterbegin', '<div class="alert alert-warning alert-sm py-1 px-2"><small>Reports & Analytics are disabled in Features.</small></div>');
        }
    }
    if (__organizerFeatures.duplicates_enabled) {
        loadDuplicates();
    } else {
        showNotification('Duplicate Detection is disabled in Features.', 'warning');
    }
    loadWatchedFolders();
});

// Statistics Charts

// Duplicate Files Management
async function loadDuplicates() {
    const btn = document.getElementById('btn-duplicates-refresh');
    const originalHtml = btn ? btn.innerHTML : '';
    const container = document.getElementById('duplicates-container');
    const countBadge = document.getElementById('duplicates-count');
    const wastedBadge = document.getElementById('wasted-space');
    
    try {
        if (btn) {
            btn.disabled = true;
            btn.innerHTML = '<span class="spinner-border spinner-border-sm me-1"></span>Scanning...';
        }
        if (container) {
            container.innerHTML = `
                <div class="text-center text-muted py-4">
                    <div class="spinner-border text-primary mb-2"></div>
                    <p class="mb-0">Scanning for duplicates...</p>
                </div>`;
        }
        
        const res = await fetch('/api/duplicates', {
            credentials: 'include',
            headers: getAuthHeaders()
        });
        
        if (!res.ok) {
            let message = 'Failed to load duplicates';
            try {
                const err = await res.json();
                message = err.error || message;
            } catch (_) {}
            throw new Error(message);
        }
        
        const data = await res.json();
        window.duplicatesData = data;
        
        if (countBadge) {
            countBadge.textContent = `${data.total_duplicates} duplicate group${data.total_duplicates === 1 ? '' : 's'}`;
        }
        if (wastedBadge) {
            wastedBadge.textContent = `${data.wasted_space_human} wasted`;
        }
        if (!container) return;
        
        if (!data.duplicates || data.duplicates.length === 0) {
            container.innerHTML = `
                <div class="text-center text-success py-4">
                    <i class="bi bi-check-circle fs-1"></i>
                    <p class="mb-0">No duplicate files found!</p>
                </div>`;
            return;
        }
        
        const cards = data.duplicates.map((group, index) => {
            const files = Array.isArray(group.files) ? group.files : [];
            const fileCount = group.count || files.length;
            const totalSizeLabel = escapeHtml(group.total_size_human || '');
            const hashPreviewRaw = (group.hash || '').substring(0, 12);
            const hashPreview = hashPreviewRaw ? escapeHtml(hashPreviewRaw) : '';
            const hashDisplay = hashPreview ? `${hashPreview}...` : 'n/a';
            const fileRows = files.map((file, fileIndex) => {
                const safePath = escapeHtml(file.path || '');
                const deletePath = JSON.stringify(file.path || '');
                const sizeLabel = escapeHtml(file.size_human || '');
                const modifiedLabel = escapeHtml(file.modified_human || '');
                return `
                    <tr>
                        <td><input type="checkbox" data-group="${index}" data-file="${fileIndex}" data-path="${safePath}"></td>
                        <td><i class="bi bi-file-earmark"></i> ${escapeHtml(file.name || 'Unknown')}</td>
                        <td>${sizeLabel || '—'}</td>
                        <td><small>${modifiedLabel || '—'}</small></td>
                        <td><small class="text-muted">${safePath}</small></td>
                        <td>
                            <button class="btn btn-sm btn-outline-danger" onclick="deleteSingleFile(${deletePath})" title="Delete this file">
                                <i class="bi bi-trash"></i>
                            </button>
                        </td>
                    </tr>
                `;
            }).join('');
            
            return `
                <div class="card mb-3">
                    <div class="card-header bg-light">
                        <div class="d-flex flex-column flex-lg-row justify-content-between align-items-lg-center gap-2">
                            <div>
                                <strong>${fileCount} files</strong> - ${totalSizeLabel || 'Unknown size'}
                                <small class="text-muted">(Hash: ${hashDisplay})</small>
                            </div>
                            <div class="d-flex flex-wrap gap-2">
                                <button class="btn btn-sm btn-outline-primary" onclick="keepNewest(${index})">
                                    <i class="bi bi-clock"></i> Keep Newest
                                </button>
                                <button class="btn btn-sm btn-outline-success" onclick="keepLargest(${index})">
                                    <i class="bi bi-file-earmark"></i> Keep Largest
                                </button>
                                <button class="btn btn-sm btn-outline-danger" onclick="deleteAllDuplicates(${index})">
                                    <i class="bi bi-trash"></i> Delete All
                                </button>
                            </div>
                        </div>
                    </div>
                    <div class="card-body p-0">
                        <div class="table-responsive">
                            <table class="table table-sm table-hover mb-0">
                                <thead>
                                    <tr>
                                        <th width="30"><input type="checkbox" onchange="toggleGroupSelection(${index}, this.checked)"></th>
                                        <th>Name</th>
                                        <th>Size</th>
                                        <th>Modified</th>
                                        <th>Path</th>
                                        <th width="80">Actions</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    ${fileRows || '<tr><td colspan="6" class="text-center text-muted">No file details available</td></tr>'}
                                </tbody>
                            </table>
                        </div>
                    </div>
                </div>
            `;
        }).join('');
        
        container.innerHTML = cards;
    } catch (error) {
        console.error('Error loading duplicates:', error);
        if (container) {
            container.innerHTML = `
                <div class="alert alert-danger mb-0">
                    <i class="bi bi-exclamation-triangle"></i> ${escapeHtml(error.message || 'Failed to load duplicates')}
                </div>`;
        }
        showNotification('Failed to load duplicates: ' + error.message, 'danger');
    } finally {
        if (btn) {
            btn.disabled = false;
            btn.innerHTML = originalHtml || '<i class="bi bi-arrow-clockwise"></i> Refresh';
        }
    }
}

async function loadWatchedFolders() {
    try {
        const res = await fetch('/api/watch_folders', {
            credentials: 'include',
            headers: { 'Authorization': __authHeader }
        });
        if (!res.ok) return;
        const data = await res.json();
        const folders = Array.isArray(data.folders) ? data.folders : [];
        const badge = document.getElementById('watched-folders-badge');
        const list = document.getElementById('watched-folders-list');
        const ul = document.getElementById('watched-folders-ul');
        if (badge) badge.textContent = `watching ${folders.length}`;
        if (ul) {
            ul.innerHTML = folders.map(f => `<li><small class="text-muted">${f}</small></li>`).join('');
        }
        if (list) list.style.display = folders.length ? 'block' : 'none';
    } catch (e) {
        console.error('Failed to load watched folders', e);
    }
}

function toggleGroupSelection(groupIndex, checked) {
    document.querySelectorAll(`input[data-group="${groupIndex}"]`).forEach(checkbox => {
        checkbox.checked = checked;
    });
}

async function keepNewest(groupIndex) {
    if (!window.duplicatesData) return;
    
    const group = window.duplicatesData.duplicates[groupIndex];
    if (!group || group.files.length < 2) return;
    
    // Keep first file (newest by sort), delete rest
    const filesToDelete = group.files.slice(1).map(f => f.path);
    
    if (!confirm(`Delete ${filesToDelete.length} older duplicate(s) and keep the newest?`)) {
        return;
    }
    
    await resolveDuplicates(filesToDelete);
}

async function keepLargest(groupIndex) {
    if (!window.duplicatesData) return;
    
    const group = window.duplicatesData.duplicates[groupIndex];
    if (!group || group.files.length < 2) return;
    
    // Find largest file
    let largest = group.files[0];
    group.files.forEach(f => {
        if (f.size > largest.size) largest = f;
    });
    
    // Delete all except largest
    const filesToDelete = group.files.filter(f => f.path !== largest.path).map(f => f.path);
    
    if (!confirm(`Delete ${filesToDelete.length} duplicate(s) and keep the largest (${largest.size_human})?`)) {
        return;
    }
    
    await resolveDuplicates(filesToDelete);
}

async function deleteAllDuplicates(groupIndex) {
    if (!window.duplicatesData) return;
    
    const group = window.duplicatesData.duplicates[groupIndex];
    if (!group) return;
    
    const filesToDelete = group.files.map(f => f.path);
    
    if (!confirm(`Delete ALL ${filesToDelete.length} files in this duplicate group? This cannot be undone!`)) {
        return;
    }
    
    await resolveDuplicates(filesToDelete);
}

async function deleteSingleFile(filePath) {
    if (!confirm(`Delete this file?\n${filePath}\n\nThis cannot be undone!`)) {
        return;
    }
    
    await resolveDuplicates([filePath]);
}

async function deleteSelectedFiles() {
    const selected = Array.from(document.querySelectorAll('input[data-path]:checked')).map(cb => cb.dataset.path);
    
    if (selected.length === 0) {
        showToast('No files selected', 'warning');
        return;
    }
    
    if (!confirm(`Delete ${selected.length} selected file(s)? This cannot be undone!`)) {
        return;
    }
    
    await resolveDuplicates(selected);
}

async function resolveDuplicates(filePaths) {
    try {
        const res = await fetch('/api/duplicates/resolve', {
            method: 'POST',
            credentials: 'include',
            headers: {
                'Content-Type': 'application/json',
                ...getAuthHeaders()
            },
            body: JSON.stringify({
                action: 'delete',
                files: filePaths
            })
        });
        
        if (res.ok) {
            const result = await res.json();
            showToast(result.message, 'success');
            
            // Reload duplicates
            loadDuplicates();
        } else {
            const error = await res.json();
            showToast('Failed to delete files: ' + (error.error || 'Unknown error'), 'error');
        }
    } catch (error) {
        console.error('Error resolving duplicates:', error);
        showToast('Error: ' + error.message, 'error');
    }
}

async function scanVirusTotal(filePath, fileName) {
    try {
        const res = await fetch('/api/recent_files/virustotal', {
            method: 'POST',
            credentials: 'include',
            headers: {
                'Content-Type': 'application/json',
                ...getAuthHeaders()
            },
            body: JSON.stringify({ path: filePath })
        });
        const data = await res.json().catch(() => ({}));
        if (res.ok) {
            const attrs = data.data && data.data.attributes;
            const stats = attrs && attrs.last_analysis_stats;
            // Toast summary
            if (stats) {
                showToast(`VT: ${fileName} clean:${stats.undetected} malicious:${stats.malicious} suspicious:${stats.suspicious||0}`, 'info');
            } else {
                showToast('VirusTotal scan requested. Check VT for detailed report.', 'info');
            }
            // Populate modal details
            try {
                const engines = attrs && attrs.last_analysis_results ? attrs.last_analysis_results : {};
                const rows = Object.keys(engines).map(name => {
                    const r = engines[name] || {};
                    const c = r.category || 'unknown';
                    const verdict = r.result || '';
                    const badge = c === 'malicious' ? 'badge bg-danger' : c === 'suspicious' ? 'badge bg-warning text-dark' : 'badge bg-success';
                    return `<tr><td><small>${name}</small></td><td><span class="${badge}">${c}</span></td><td><small>${verdict}</small></td></tr>`;
                }).join('');
                const sha256 = attrs && attrs.sha256 ? attrs.sha256 : '';
                const link = sha256 ? `https://www.virustotal.com/gui/file/${sha256}` : '#';
                const bodyHtml = `
                    <div class="mb-2"><strong>${escapeHtml(fileName)}</strong></div>
                    ${stats ? `<div class="mb-3">Malicious: ${stats.malicious} • Suspicious: ${stats.suspicious||0} • Undetected: ${stats.undetected} • Harmless: ${stats.harmless||0}</div>` : ''}
                    <div class="table-responsive">
                        <table class="table table-sm">
                            <thead><tr><th>Engine</th><th>Status</th><th>Verdict</th></tr></thead>
                            <tbody>${rows || '<tr><td colspan="3" class="text-muted">No engine results</td></tr>'}</tbody>
                        </table>
                    </div>`;
                const modalBody = document.getElementById('vtModalBody');
                const modalLink = document.getElementById('vtReportLink');
                if (modalBody) modalBody.innerHTML = bodyHtml;
                if (modalLink) modalLink.href = link;
                // Show modal
                const modalEl = document.getElementById('vtModal');
                if (modalEl && typeof bootstrap !== 'undefined') {
                    const modal = bootstrap.Modal.getOrCreateInstance(modalEl);
                    modal.show();
                }
            } catch (e) {
                console.warn('Failed to render VT modal:', e);
            }
        } else {
            showToast('VirusTotal error: ' + (data.error || res.status), 'error');
        }
    } catch (e) {
        showToast('VirusTotal request failed: ' + e.message, 'error');
    }
}
// Statistics Charts
let chartCategory, chartExtensions, chartTimeline, chartHourly;

async function loadStatistics() {
    try {
        // Load overview stats
        const overviewRes = await fetch('/api/statistics/overview', {
            credentials: 'include',
            headers: { 'Authorization': __authHeader }
        });
        
        if (overviewRes.ok) {
            const overview = await overviewRes.json();
            document.getElementById('stat-total-files').textContent = overview.total_files || 0;
            document.getElementById('stat-today').textContent = overview.today_count || 0;
            document.getElementById('stat-week').textContent = overview.week_count || 0;
            document.getElementById('stat-month').textContent = overview.month_count || 0;
            document.getElementById('stat-categories').textContent = overview.total_categories || 0;
            document.getElementById('stat-avg-day').textContent = overview.avg_per_day || 0;
        }
        
        // Load category chart
        const categoryRes = await fetch('/api/statistics/by-category', {
            credentials: 'include',
            headers: { 'Authorization': __authHeader }
        });
        
        if (categoryRes.ok) {
            const categoryData = await categoryRes.json();
            const ctx = document.getElementById('chart-category');
            if (ctx) {
                if (chartCategory) chartCategory.destroy();
                chartCategory = new Chart(ctx, {
                    type: 'doughnut',
                    data: {
                        labels: categoryData.labels || [],
                        datasets: [{
                            data: categoryData.data || [],
                            backgroundColor: [
                                '#0d6efd', '#6610f2', '#6f42c1', '#d63384', '#dc3545',
                                '#fd7e14', '#ffc107', '#198754', '#20c997', '#0dcaf0'
                            ]
                        }]
                    },
                    options: {
                        responsive: true,
                        plugins: {
                            legend: {
                                position: 'right'
                            }
                        }
                    }
                });
            }
        }
        
        // Load extensions chart
        const extRes = await fetch('/api/statistics/by-extension', {
            credentials: 'include',
            headers: { 'Authorization': __authHeader }
        });
        
        if (extRes.ok) {
            const extData = await extRes.json();
            const ctx = document.getElementById('chart-extensions');
            if (ctx) {
                if (chartExtensions) chartExtensions.destroy();
                chartExtensions = new Chart(ctx, {
                    type: 'bar',
                    data: {
                        labels: extData.labels || [],
                        datasets: [{
                            label: 'Files',
                            data: extData.data || [],
                            backgroundColor: '#0d6efd'
                        }]
                    },
                    options: {
                        responsive: true,
                        plugins: {
                            legend: {
                                display: false
                            }
                        },
                        scales: {
                            y: {
                                beginAtZero: true,
                                ticks: {
                                    stepSize: 1
                                }
                            }
                        }
                    }
                });
            }
        }
        
        // Load timeline chart
        const timelineRes = await fetch('/api/statistics/timeline', {
            credentials: 'include',
            headers: { 'Authorization': __authHeader }
        });
        
        if (timelineRes.ok) {
            const timelineData = await timelineRes.json();
            const ctx = document.getElementById('chart-timeline');
            if (ctx) {
                if (chartTimeline) chartTimeline.destroy();
                chartTimeline = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: timelineData.labels || [],
                        datasets: [{
                            label: 'Files Organized',
                            data: timelineData.data || [],
                            borderColor: '#198754',
                            backgroundColor: 'rgba(25, 135, 84, 0.1)',
                            fill: true,
                            tension: 0.4
                        }]
                    },
                    options: {
                        responsive: true,
                        plugins: {
                            legend: {
                                display: false
                            }
                        },
                        scales: {
                            y: {
                                beginAtZero: true,
                                ticks: {
                                    stepSize: 1
                                }
                            },
                            x: {
                                ticks: {
                                    maxRotation: 45,
                                    minRotation: 45
                                }
                            }
                        }
                    }
                });
            }
        }
        
        // Load hourly activity chart
        const hourlyRes = await fetch('/api/statistics/hourly-activity', {
            credentials: 'include',
            headers: { 'Authorization': __authHeader }
        });
        
        if (hourlyRes.ok) {
            const hourlyData = await hourlyRes.json();
            const ctx = document.getElementById('chart-hourly');
            if (ctx) {
                if (chartHourly) chartHourly.destroy();
                chartHourly = new Chart(ctx, {
                    type: 'bar',
                    data: {
                        labels: hourlyData.labels || [],
                        datasets: [{
                            label: 'Files',
                            data: hourlyData.data || [],
                            backgroundColor: '#0dcaf0'
                        }]
                    },
                    options: {
                        responsive: true,
                        plugins: {
                            legend: {
                                display: false
                            }
                        },
                        scales: {
                            y: {
                                beginAtZero: true,
                                ticks: {
                                    stepSize: 1
                                }
                            }
                        }
                    }
                });
            }
        }
        
    } catch (err) {
        console.error('Failed to load statistics:', err);
    }
}

// Notification Center Functions
let notificationCenterOpen = false;

async function loadNotificationCenter() {
    try {
        const response = await fetch('/api/notifications', {
            credentials: 'include',
            headers: { 'Authorization': __authHeader }
        });
        
        if (response.ok) {
            const data = await response.json();
            updateNotificationBadge(data.unread);
            renderNotifications(data.notifications);
        }
    } catch (err) {
        console.error('Failed to load notifications:', err);
    }
}

function updateNotificationBadge(count) {
    const badge = document.getElementById('notification-badge');
    if (badge) {
        if (count > 0) {
            badge.textContent = count > 99 ? '99+' : count;
            badge.style.display = 'flex';
        } else {
            badge.style.display = 'none';
        }
    }
}

function renderNotifications(notifications) {
    const body = document.getElementById('notification-body');
    if (!body) return;
    
    if (notifications.length === 0) {
        body.innerHTML = `
            <div class="notification-empty">
                <i class="bi bi-bell-slash"></i>
                <p>No notifications</p>
            </div>
        `;
        return;
    }
    
    body.innerHTML = notifications.map(notif => {
        const unreadClass = notif.read ? '' : 'unread';
        const typeIcon = getNotificationIcon(notif.type);
        const time = formatNotificationTime(notif.timestamp);
        
        return `
            <div class="notification-item ${unreadClass}" onclick="markNotificationRead('${notif.id}')">
                <div class="notification-message">
                    <i class="bi ${typeIcon}"></i> ${notif.message}
                </div>
                <div class="notification-time">${time}</div>
                <i class="bi bi-x-circle notification-delete" onclick="event.stopPropagation(); deleteNotification('${notif.id}')"></i>
            </div>
        `;
    }).join('');
}

function getNotificationIcon(type) {
    const icons = {
        'success': 'bi-check-circle-fill text-success',
        'danger': 'bi-exclamation-triangle-fill text-danger',
        'warning': 'bi-exclamation-circle-fill text-warning',
        'info': 'bi-info-circle-fill text-info'
    };
    return icons[type] || icons.info;
}

function formatNotificationTime(timestamp) {
    try {
        const date = new Date(timestamp);
        const now = new Date();
        const diffMs = now - date;
        const diffMins = Math.floor(diffMs / 60000);
        const diffHours = Math.floor(diffMs / 3600000);
        const diffDays = Math.floor(diffMs / 86400000);
        
        if (diffMins < 1) return 'Just now';
        if (diffMins < 60) return `${diffMins}m ago`;
        if (diffHours < 24) return `${diffHours}h ago`;
        if (diffDays < 7) return `${diffDays}d ago`;
        return date.toLocaleDateString();
    } catch (err) {
        return '';
    }
}

function toggleNotificationCenter() {
    const dropdown = document.getElementById('notification-dropdown');
    if (!dropdown) return;
    
    notificationCenterOpen = !notificationCenterOpen;
    
    if (notificationCenterOpen) {
        dropdown.classList.add('show');
        loadNotificationCenter();
        // Close when clicking outside
        setTimeout(() => {
            document.addEventListener('click', closeNotificationCenter);
        }, 100);
    } else {
        dropdown.classList.remove('show');
        document.removeEventListener('click', closeNotificationCenter);
    }
}

function closeNotificationCenter(event) {
    const dropdown = document.getElementById('notification-dropdown');
    const bell = document.querySelector('.notification-bell');
    
    if (dropdown && bell && !dropdown.contains(event.target) && !bell.contains(event.target)) {
        dropdown.classList.remove('show');
        notificationCenterOpen = false;
        document.removeEventListener('click', closeNotificationCenter);
    }
}

async function markNotificationRead(notificationId) {
    try {
        await fetch(`/api/notifications/${notificationId}/read`, {
            method: 'POST',
            credentials: 'include',
            headers: { 
                'Authorization': __authHeader,
                'Content-Type': 'application/json'
            }
        });
        loadNotificationCenter();
    } catch (err) {
        console.error('Failed to mark notification as read:', err);
    }
}

async function markAllNotificationsRead() {
    try {
        await fetch('/api/notifications/mark-all-read', {
            method: 'POST',
            credentials: 'include',
            headers: { 
                'Authorization': __authHeader,
                'Content-Type': 'application/json'
            }
        });
        loadNotificationCenter();
        showNotification('All notifications marked as read', 'success');
    } catch (err) {
        console.error('Failed to mark all as read:', err);
    }
}

async function clearAllNotifications() {
    if (!confirm('Clear all notifications? This cannot be undone.')) return;
    
    try {
        await fetch('/api/notifications/clear', {
            method: 'POST',
            credentials: 'include',
            headers: { 
                'Authorization': __authHeader,
                'Content-Type': 'application/json'
            }
        });
        loadNotificationCenter();
        showNotification('All notifications cleared', 'success');
    } catch (err) {
        console.error('Failed to clear notifications:', err);
    }
}

async function deleteNotification(notificationId) {
    try {
        await fetch(`/api/notifications/${notificationId}`, {
            method: 'DELETE',
            credentials: 'include',
            headers: { 
                'Authorization': __authHeader,
                'Content-Type': 'application/json'
            }
        });
        loadNotificationCenter();
    } catch (err) {
        console.error('Failed to delete notification:', err);
    }
}

// Enhanced showNotification with notification center integration
// (Note: original showNotification is defined earlier in the script)
function showNotificationWithHistory(message, type) {
    // Show toast notification using original function
    showNotification(message, type);
    
    // Save to notification center
    fetch('/api/notifications', {
        method: 'POST',
        credentials: 'include',
        headers: { 
            'Authorization': __authHeader,
            'Content-Type': 'application/json'
        },
        body: JSON.stringify({ message, type })
    }).then(() => {
        // Update badge count
        loadNotificationCenter();
    }).catch(err => {
        console.error('Failed to save notification:', err);
    });
}

// Load notification center on page load
document.addEventListener('DOMContentLoaded', function() {
    loadNotificationCenter();
    // Refresh notification center every 30 seconds
    setInterval(loadNotificationCenter, 30000);
    // Check if we should show intro
    checkShowIntro();
});

// Keyboard Shortcuts and Command Palette
const commands = [
    { name: 'Toggle Dark Mode', icon: 'bi-moon-stars', shortcut: 'Ctrl+D', action: () => toggleTheme() },
    { name: 'Refresh Dashboard', icon: 'bi-arrow-clockwise', shortcut: 'Ctrl+R', action: () => location.reload() },
    { name: 'Open Notifications', icon: 'bi-bell', shortcut: 'Ctrl+N', action: () => toggleNotificationCenter() },
    { name: 'Show Keyboard Shortcuts', icon: 'bi-keyboard', shortcut: '?', action: () => showHelpModal() },
    { name: 'View Changelog', icon: 'bi-clock-history', shortcut: 'Ctrl+L', action: () => showChangelog() },
    { name: 'About Dashboard', icon: 'bi-info-circle', shortcut: 'Ctrl+H', action: () => showAboutModal() },
    { name: 'Go to Config Page', icon: 'bi-gear', shortcut: '', action: () => window.location.href = '/config' },
    { name: 'Refresh Statistics', icon: 'bi-graph-up', shortcut: '', action: () => loadStatistics() },
    { name: 'Reset Dashboard Layout', icon: 'bi-arrow-counterclockwise', shortcut: '', action: () => resetDashboardLayout() },
    { name: 'Show Hidden Modules', icon: 'bi-eye', shortcut: '', action: () => showHiddenModules() },
    { name: 'Logout', icon: 'bi-box-arrow-right', shortcut: '', action: () => logout() }
];

let selectedCommandIndex = 0;

// Global keyboard shortcut handler
document.addEventListener('keydown', function(e) {
    // Ctrl+K - Command Palette
    if (e.ctrlKey && e.key === 'k') {
        e.preventDefault();
        openCommandPalette();
        return;
    }
    
    // Ctrl+D - Toggle Dark Mode
    if (e.ctrlKey && e.key === 'd') {
        e.preventDefault();
        toggleTheme();
        return;
    }
    
    // Ctrl+R - Refresh (allow default but show notification)
    if (e.ctrlKey && e.key === 'r') {
        // Let browser handle refresh
        return;
    }
    
    // Ctrl+N - Open Notifications
    if (e.ctrlKey && e.key === 'n') {
        e.preventDefault();
        toggleNotificationCenter();
        return;
    }
    
    // Ctrl+L - Changelog
    if (e.ctrlKey && e.key === 'l') {
        e.preventDefault();
        showChangelog();
        return;
    }
    
    // Ctrl+H - About
    if (e.ctrlKey && e.key === 'h') {
        e.preventDefault();
        showAboutModal();
        return;
    }
    
    // ? - Show Help (when not in input field)
    if (e.key === '?' && !['INPUT', 'TEXTAREA'].includes(e.target.tagName)) {
        e.preventDefault();
        showHelpModal();
        return;
    }
    
    // Escape - Close all modals
    if (e.key === 'Escape') {
        closeCommandPalette();
        closeHelpModal();
        closeAboutModal();
        closeChangelogModal();
        closeIntroModal();
        if (notificationCenterOpen) {
            toggleNotificationCenter();
        }
        return;
    }
    
    // Arrow keys in command palette
    if (document.getElementById('command-palette-overlay').classList.contains('show')) {
        if (e.key === 'ArrowDown') {
            e.preventDefault();
            selectedCommandIndex = Math.min(selectedCommandIndex + 1, commands.length - 1);
            updateCommandSelection();
        } else if (e.key === 'ArrowUp') {
            e.preventDefault();
            selectedCommandIndex = Math.max(selectedCommandIndex - 1, 0);
            updateCommandSelection();
        } else if (e.key === 'Enter') {
            e.preventDefault();
            executeSelectedCommand();
        }
    }
});

function openCommandPalette() {
    const overlay = document.getElementById('command-palette-overlay');
    const input = document.getElementById('command-palette-input');
    overlay.classList.add('show');
    input.value = '';
    input.focus();
    selectedCommandIndex = 0;
    renderCommands(commands);
}

function closeCommandPalette() {
    const overlay = document.getElementById('command-palette-overlay');
    overlay.classList.remove('show');
}

function renderCommands(commandList) {
    const results = document.getElementById('command-palette-results');
    
    if (commandList.length === 0) {
        results.innerHTML = '<div class="command-palette-empty">No commands found</div>';
        return;
    }
    
    results.innerHTML = commandList.map((cmd, index) => `
        <div class="command-palette-item ${index === selectedCommandIndex ? 'selected' : ''}" 
             onclick="executeCommand(${index})" 
             data-index="${index}">
            <i class="bi ${cmd.icon}"></i>
            <span class="command-name">${cmd.name}</span>
            ${cmd.shortcut ? `<span class="command-shortcut">${cmd.shortcut}</span>` : ''}
        </div>
    `).join('');
}

function updateCommandSelection() {
    document.querySelectorAll('.command-palette-item').forEach((item, index) => {
        if (index === selectedCommandIndex) {
            item.classList.add('selected');
            item.scrollIntoView({ block: 'nearest' });
        } else {
            item.classList.remove('selected');
        }
    });
}

function executeCommand(index) {
    if (commands[index]) {
        closeCommandPalette();
        commands[index].action();
    }
}

function executeSelectedCommand() {
    executeCommand(selectedCommandIndex);
}

// Command palette search
document.getElementById('command-palette-input').addEventListener('input', function(e) {
    const query = e.target.value.toLowerCase();
    const filtered = commands.filter(cmd => 
        cmd.name.toLowerCase().includes(query) || 
        cmd.shortcut.toLowerCase().includes(query)
    );
    selectedCommandIndex = 0;
    renderCommands(filtered);
});

// Help Modal Functions
function showHelpModal() {
    document.getElementById('help-modal-overlay').classList.add('show');
}

function closeHelpModal() {
    document.getElementById('help-modal-overlay').classList.remove('show');
}

// About Modal Functions
function showAboutModal() {
    document.getElementById('about-modal-overlay').classList.add('show');
}

function closeAboutModal() {
    document.getElementById('about-modal-overlay').classList.remove('show');
}

// Changelog Functions
async function showChangelog() {
    const overlay = document.getElementById('changelog-modal-overlay');
    const content = document.getElementById('changelog-content');
    
    overlay.classList.add('show');
    
    try {
        const response = await fetch('/CHANGELOG.md');
        if (response.ok) {
            let markdown = await response.text();
            // Simple markdown to HTML conversion
            content.innerHTML = markdownToHtml(markdown);
        } else {
            content.innerHTML = '<p class="text-danger">Failed to load changelog.</p>';
        }
    } catch (err) {
        content.innerHTML = '<p class="text-danger">Error loading changelog: ' + err.message + '</p>';
    }
}

function closeChangelogModal() {
    document.getElementById('changelog-modal-overlay').classList.remove('show');
}

function markdownToHtml(markdown) {
    return markdown
        .replace(/^### (.+)$/gm, '<h5 class="mt-3">$1</h5>')
        .replace(/^## (.+)$/gm, '<h4 class="mt-4">$1</h4>')
        .replace(/^# (.+)$/gm, '<h3 class="mt-4">$1</h3>')
        .replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>')
        .replace(/\*(.+?)\*/g, '<em>$1</em>')
        .replace(/^- (.+)$/gm, '<li>$1</li>')
        .replace(/(<li>.*<\/li>\n?)+/g, '<ul>$&</ul>')
        .replace(/\n\n/g, '</p><p>')
        .replace(/^(?!<[h|u|l])/gm, '<p>')
        .replace(/(?<![>])$/gm, '</p>')
        .replace(/<p><\/p>/g, '')
        .replace(/\[([^\]]+)\]\(([^)]+)\)/g, '<a href="$2" target="_blank">$1</a>');
}

// Intro Modal Functions
function checkShowIntro() {
    const dontShow = localStorage.getItem('dontShowIntro');
    if (!dontShow) {
        setTimeout(() => {
            document.getElementById('intro-modal-overlay').classList.add('show');
        }, 1000);
    }
}

function closeIntroModal() {
    const dontShow = document.getElementById('dont-show-intro').checked;
    if (dontShow) {
        localStorage.setItem('dontShowIntro', 'true');
    }
    document.getElementById('intro-modal-overlay').classList.remove('show');
}

// Mobile Collapsible Cards
function initMobileCollapsible() {
    if (window.innerWidth <= 768) {
        document.querySelectorAll('.dashboard-module .card-header, .config-module .card-header').forEach(header => {
            // Only add click handler once
            if (!header.dataset.collapsibleInit) {
                header.dataset.collapsibleInit = 'true';
                header.addEventListener('click', function(e) {
                    // Don't collapse if clicking on a button or input
                    if (e.target.tagName === 'BUTTON' || e.target.tagName === 'INPUT' || 
                        e.target.closest('button') || e.target.closest('.drag-handle') || 
                        e.target.closest('.hide-toggle')) {
                        return;
                    }
                    const module = this.closest('.dashboard-module, .config-module');
                    if (module) {
                        module.classList.toggle('collapsed');
                    }
                });
            }
        });
    }
}

// Re-init on resize
let resizeTimer;
window.addEventListener('resize', function() {
    clearTimeout(resizeTimer);
    resizeTimer = setTimeout(function() {
        initMobileCollapsible();
    }, 250);
});

// Initialize mobile features on load
document.addEventListener('DOMContentLoaded', function() {
    initMobileCollapsible();
});
</script>
<script>
// Note: Service control functions (startService, stopService, restartService, serviceAction, updateServiceStatus)
// are already defined earlier in dashboard_scripts.html around line 856-900.

// Export implementations to window for inline handlers
(function(){
    const exportNames = [
        'promptLogin','logout','resetDashboardLayout','addCustomWidget','editCustomWidget','removeCustomWidget',
        'saveCustomWidgets','loadCustomWidgets','initSidebarResizer','initDragAndDrop','saveDashboardLayout','loadDashboardLayout',
        'showNotification','toggleNotificationCenter','markAllNotificationsRead','clearAllNotifications',
        'revealPublicIP','hidePublicIP','extractPublicIP','copyPublicIP',
        'loadDuplicates','loadWatchedFolders','refreshRecentFiles','copyServiceName','copyToClipboard','deleteRow',
        'toggleHideModule','saveSettings','addCategoryRow','saveConfiguration','addCustomRouteRow','addTagRouteRow',
        'devResetToSetup','initResizableTables','initMobileCollapsible','updateServiceStatus',
        'startService','stopService','restartService','serviceAction','showHiddenModules'
    ];
    exportNames.forEach(function(name){
        try {
            if (typeof window[name] !== 'function' && typeof eval(name) === 'function') {
                window[name] = eval(name);
            }
        } catch(e) {}
    });
})();
</script>
<script>
// Bind UI events to real implementations (rewire from inline handlers)
document.addEventListener('DOMContentLoaded', function(){
    const byId = (id)=>document.getElementById(id);
    const bind = (id, handler)=>{ const el = byId(id); if(el && typeof handler === 'function') el.addEventListener('click', handler); };

    // Auth & main controls
    bind('login-btn', window.promptLogin);
    bind('login-btn-sidebar', window.promptLogin);
    bind('logout-btn', window.logout);
    bind('logout-btn-sidebar', window.logout);
    bind('btn-show-hidden', window.showHiddenModules);
    bind('btn-reset-layout', window.resetDashboardLayout);
    bind('btn-add-widget', window.addCustomWidget);
    bind('reset-layout-btn', window.resetDashboardLayout);
    bind('show-hidden-btn', window.showHiddenModules);
    bind('dev-reset-btn', window.devResetToSetup);
    bind('dev-reset-btn-sidebar', window.devResetToSetup);
    
    // Service controls
    bind('btn-start-service', window.startService);
    bind('btn-stop-service', window.stopService);
    bind('btn-restart-service', window.restartService);
    bind('service-name-btn', window.copyServiceName);
    
    // Module actions
    bind('btn-duplicates-refresh', window.loadDuplicates);
    bind('btn-recent-refresh', window.refreshRecentFiles);
    bind('btn-save-settings', window.saveSettings);
    bind('btn-add-category', window.addCategoryRow);
    bind('btn-save-config', window.saveConfiguration);
    bind('btn-add-custom-route', window.addCustomRouteRow);
    bind('btn-save-custom-routes', window.saveConfiguration);
    bind('btn-add-tag-route', window.addTagRouteRow);
    bind('btn-save-tag-routes', window.saveConfiguration);
    
    // Event delegation for hide toggles (data-module attribute)
    document.addEventListener('click', function(e){
        const toggle = e.target.closest('.hide-toggle');
        if(toggle && toggle.dataset.module && typeof window.toggleHideModule === 'function'){
            window.toggleHideModule(toggle.dataset.module);
        }
        
        // Delete row buttons (onclick="deleteRow(this)")
        if(e.target.matches('button') && e.target.textContent.trim() === 'Delete' && typeof window.deleteRow === 'function'){
            window.deleteRow(e.target);
        }
        
        // Copy-value spans with copyToClipboard
        const copySpan = e.target.closest('.copy-value');
        if(copySpan && typeof window.copyToClipboard === 'function'){
            const text = copySpan.textContent.trim();
            window.copyToClipboard(text, copySpan);
        }
    });
    
    // Public IP hover/out events
    const publicIpSpan = byId('public-ip-display');
    if(publicIpSpan){
        publicIpSpan.addEventListener('mouseover', window.revealPublicIP);
        publicIpSpan.addEventListener('mouseout', window.hidePublicIP);
        publicIpSpan.addEventListener('click', function(){ if(typeof window.copyPublicIP === 'function') window.copyPublicIP(this); });
    }
    
    // Extract public IP iframe onload
    const ipFrame = byId('ipchicken-frame');
    if(ipFrame && typeof window.extractPublicIP === 'function'){
        ipFrame.addEventListener('load', window.extractPublicIP);
    }
});
</script>
