"""
Request Debouncing & Rate Limiting
Prevents excessive API calls and coalesces duplicate requests
"""

import time
from functools import wraps
from collections import defaultdict
from typing import Dict, Any, Callable

class RateLimiter:
    """Rate limiter with sliding window"""
    
    def __init__(self):
        self.requests: Dict[str, list] = defaultdict(list)
        self.cleanup_interval = 60  # Cleanup old entries every 60s
        self.last_cleanup = time.time()
    
    def is_allowed(self, key: str, max_requests: int, window_seconds: int) -> bool:
        """Check if request is allowed for given key"""
        now = time.time()
        
        # Cleanup old entries periodically
        if now - self.last_cleanup > self.cleanup_interval:
            self._cleanup(now)
            self.last_cleanup = now
        
        # Remove requests outside the window
        cutoff = now - window_seconds
        self.requests[key] = [t for t in self.requests[key] if t > cutoff]
        
        # Check if limit exceeded
        if len(self.requests[key]) >= max_requests:
            return False
        
        # Record this request
        self.requests[key].append(now)
        return True
    
    def _cleanup(self, now: float):
        """Remove keys with no recent requests"""
        keys_to_remove = [
            k for k, v in self.requests.items()
            if not v or all(t < now - 300 for t in v)
        ]
        for k in keys_to_remove:
            del self.requests[k]

class RequestDeduplicator:
    """Deduplicates concurrent requests for same resource"""
    
    def __init__(self):
        self.pending_requests: Dict[str, tuple] = {}
        self.cache_timeout = 1  # Cache result for 1 second
    
    def get_or_create(self, key: str, func: Callable, timeout: float = None) -> Any:
        """
        Get cached result or create new request
        Returns cached result if available and fresh
        """
        now = time.time()
        
        if key in self.pending_requests:
            cached_result, timestamp = self.pending_requests[key]
            if now - timestamp < (timeout or self.cache_timeout):
                return cached_result
        
        # Request is stale, will be regenerated by caller
        return None
    
    def set_result(self, key: str, result: Any):
        """Cache result of request"""
        self.pending_requests[key] = (result, time.time())
    
    def clear(self, key: str):
        """Clear cached result"""
        if key in self.pending_requests:
            del self.pending_requests[key]

# Global instances
rate_limiter = RateLimiter()
request_deduplicator = RequestDeduplicator()

def rate_limit(max_requests: int = 10, window_seconds: int = 60):
    """
    Decorator for rate limiting by IP address
    
    Args:
        max_requests: Max requests allowed in window
        window_seconds: Time window in seconds
    
    Example:
        @app.route('/api/expensive-operation')
        @rate_limit(max_requests=5, window_seconds=60)
        def expensive_op():
            return jsonify({'status': 'ok'})
    """
    def decorator(f):
        @wraps(f)
        def decorated_function(*args, **kwargs):
            from flask import request, jsonify
            
            # Rate limit by IP address
            client_ip = request.remote_addr
            key = f"{client_ip}:{request.path}"
            
            if not rate_limiter.is_allowed(key, max_requests, window_seconds):
                return jsonify({'error': 'Rate limit exceeded'}), 429
            
            return f(*args, **kwargs)
        
        return decorated_function
    return decorator

def deduplicate_request(timeout: float = 1.0):
    """
    Decorator for deduplicating concurrent requests
    Multiple simultaneous requests for same endpoint return same cached result
    
    Args:
        timeout: Cache result for N seconds
    
    Example:
        @app.route('/api/expensive-read')
        @deduplicate_request(timeout=2.0)
        def expensive_read():
            return jsonify(expensive_calculation())
    """
    def decorator(f):
        @wraps(f)
        def decorated_function(*args, **kwargs):
            from flask import request
            
            # Create unique key for this request
            key = f"{request.path}:{request.query_string.decode('utf-8')}"
            
            # Check if we have a cached result
            cached = request_deduplicator.get_or_create(key, f, timeout)
            if cached is not None:
                return cached
            
            # Generate new result
            result = f(*args, **kwargs)
            request_deduplicator.set_result(key, result)
            return result
        
        return decorated_function
    return decorator

def client_debounce_hint(debounce_ms: int = 500):
    """
    Decorator that adds debounce hint to response headers
    Client JS can use this to know optimal debounce time
    
    Args:
        debounce_ms: Suggested debounce time in milliseconds
    
    Example:
        @app.route('/api/search')
        @client_debounce_hint(debounce_ms=300)
        def search():
            return jsonify(results)
    """
    def decorator(f):
        @wraps(f)
        def decorated_function(*args, **kwargs):
            from flask import make_response
            
            result = f(*args, **kwargs)
            
            # Convert to response if needed
            if isinstance(result, dict):
                response = make_response(result)
            else:
                response = make_response(result)
            
            # Add debounce hint header
            response.headers['X-Debounce-Hint'] = str(debounce_ms)
            
            return response
        
        return decorated_function
    return decorator

# Example usage and defaults for common endpoints
RATE_LIMITS = {
    '/api/statistics': (10, 60),          # 10 requests per 60s
    '/api/duplicates': (5, 60),            # 5 requests per 60s
    '/api/duplicates/resolve': (3, 60),    # 3 requests per 60s
    '/api/file-history': (20, 60),        # 20 requests per 60s
    '/stream/metrics': (1, 1),             # Only 1 SSE connection per IP
    '/stream/notifications': (1, 1),       # Only 1 SSE connection per ip
    '/api/search': (15, 60),               # 15 requests per 60s
}

DEBOUNCE_HINTS = {
    '/api/search': 300,                    # 300ms debounce
    '/api/tags': 200,                      # 200ms debounce
    '/api/categories': 200,                # 200ms debounce
}
